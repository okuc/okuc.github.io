<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的后院自留地</title>
  <meta name="author" content="okuc">
  
  <meta name="description" content="Ajax d3 echarts  threejs hadoop hbase cassandra hive elasticsearch spider html5">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="我的后院自留地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="我的后院自留地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">我的后院自留地</a></h1>
  <h2><a href="/">琴棋书画诗酒花，当年件件不离它；而今七字都变更，柴米油盐酱醋茶。</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/coding">编程技术</a></li>
    
      <li><a href="/bigData">大数据技术</a></li>
    
      <li><a href="/dataV">数据可视化</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-08-22T14:35:02.000Z"><a href="/2015/08/22/《Elasticsearch服务器开发》学习笔记（三）/">2015-08-22</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/22/《Elasticsearch服务器开发》学习笔记（三）/">《Elasticsearch服务器开发》学习笔记（三）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="第2章_映射配置(二)">第2章 映射配置(二)</h2><p><strong>本系列是本人在学习《Elasticsearch服务器开发》一书中所做的读书笔记，如有读不懂的地方，请直接参考原书。建议直接购买原书，支持正版。</strong></p>
<hr>
<ol>
<li>lucene 4.0后，允许修改默认的基于TF/IDF的算法。4.0还附加了相似度模型，允许在文档中使用不同的评分公式。</li>
<li><p>为每个字段设置不同的相似度模型。如下例子：</p>
<pre><code>{
   "mappings":{
       "post":{
           “properties”：{
               “id”：{“type”：“long”，“store”：“yes”，“precision_step”：“<span class="operator">0”}，
               “<span class="keyword">name</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">string</span>”，“<span class="keyword">store</span>”：“yes”，“<span class="keyword">index</span>”：“analyzed”,<span class="string">"similarity"</span>:<span class="string">"BM25"</span>}，
               “published”：{“<span class="keyword">type</span>”：“<span class="built_in">date</span>”，“<span class="keyword">store</span>”：“yes”，“precision_step”：“<span class="number">0</span>”}，
               “<span class="keyword">contents</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">long</span>”，“<span class="keyword">store</span>”：“<span class="keyword">no</span>”，“<span class="keyword">index</span>”：“analyzed”},<span class="string">"similarity"</span>:<span class="string">"BM25"</span>
               }
           }
     }

}</span>
</code></pre><p>可给name字段和contents字段中使用BM25相似度模型，修改如下：</p>
<pre><code>{
   "mappings":{
       "post":{
           “properties”：{
               “id”：{“type”：“long”，“store”：“yes”，“precision_step”：“<span class="operator">0”}，
               “<span class="keyword">name</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">string</span>”，“<span class="keyword">store</span>”：“yes”，“<span class="keyword">index</span>”：“analyzed”,<span class="string">"similarity"</span>:<span class="string">"BM25"</span>}，
               “published”：{“<span class="keyword">type</span>”：“<span class="built_in">date</span>”，“<span class="keyword">store</span>”：“yes”，“precision_step”：“<span class="number">0</span>”}，
               “<span class="keyword">contents</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">long</span>”，“<span class="keyword">store</span>”：“<span class="keyword">no</span>”，“<span class="keyword">index</span>”：“analyzed”,<span class="string">"similarity"</span>:<span class="string">"BM25"</span>}
               }
           }
     }
   }</span>
</code></pre></li>
<li><p>可用的相似度模型：</p>
<ul>
<li>Okapi BM25模型：基于概率模型，概率模型估算根据指定查询找到指定文档的概率。这种模型在处理简短的文本文档时表现最佳，在这种文档中词条的重复严重有损整体文档的得分。它使用<code>BM25</code>作为名称。</li>
<li><p>随机性偏差模型：基于具有相同名称的概率模型。为了在ES中全名用，以<code>DFR</code>为名称。它在处理类自然语言时表现良好。它的配置如下：</p>
<ul>
<li>basic_model：值为be、d、g、if、in或ine。</li>
<li>after_effect：值为no、b或l</li>
<li>normalization：值为no、h1、h2、h3或z。它的值如果不是no，则还需要设置范式化因子<code>normalizationfactor</code>。即，如果它的值是h1，则设置normalization.h1.c(浮点值)；如果是h2，则，则设置normalization.h1.c(浮点值)\normalization.h2.c\normalization.z.z</li>
<li>一个典型的配置例子<pre><code><span class="string">"similarity"</span>:{
    “esserverbook_dfr_similarity”：{
        “<span class="keyword">type</span>”：“DFR”，
      “basic_model”：“<span class="keyword">g</span>”，
      “after_effect”：“<span class="keyword">l</span>”，
      “normalization”：“h2”，
      “normalization.h2.c”：“2.0”
        }
</code></pre></li>
</ul>
</li>
<li><p>信息基础模型：与随机性偏差模型相似，以<code>IB</code>为名称，它也在处理类自然语言时表现良好。它有以下参数可供设置：</p>
<ul>
<li>distribution:值为ll或spl。</li>
<li>lambda属性：df和tff。它也可设置范式化因子。下面是一个例子（也是放到settings部分中。）</li>
<li><p>一个例子：</p>
<pre><code><span class="string">"similarity"</span>:{
    “esserverbook_ib_similarity”：{
        “<span class="typedef"><span class="keyword">type</span>”：“<span class="type">IB</span>”，</span>
      “distribution”：“ll”，
      “lambda”：“df”，
      “normalization”：“z”，
      “normalization.z.z”：“<span class="number">0.25</span>”
        }
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>信息格式：Lucene4.0可以改变索此文件写入的方式。ES利用此功能，可以为每个字段指定信息格式。有时需要改变字段被索引的方式以提高性能，比如为了使主键查找更快。ES中的信息格式如下：</p>
<ul>
<li>default:没有明确格式时，此默认信息格式将被使用。它提供了实时的对存储字段和词量的压缩。压缩内容参见<a href="http://solr.pl/en/2012/11/19/solr-4-1-stored-fields-compression/" target="_blank" rel="external"></a></li>
<li>pulsing:它将高基数字段的信息列表编码为词条矩阵。这让lucene检索文档时可以少执行一个搜索。对高基数字段使用此信处式可以加快此字段的查询速度。（高基数字段：基数越高时，字段的重复值越少，可选性越高。）</li>
<li>direct：此格式可在读操作过程中将词条加载到矩阵中。这些矩阵未经压缩保存在内存中。所以点用内存量特别大，要慎重。</li>
<li>memory：将所有的数据都写入内存，但需要一个名为FST的结构读取词条和信息列表到内存中。</li>
<li>bloom_default:默认信息扩展，增加了把布隆过滤器写入磁盘的功能。在读取过程中，布隆过滤器被读入并存入内存，以便非常快速地检查给定的值是否存在。此格式对高基数字相当有效。</li>
<li>bloom_pulsing:这是pulsing信息格式的扩展，除了pulsing格式的功能，还使用了布隆过滤器。</li>
</ul>
<p>信息格式可在每个字段上设置，就像type和name。为了把字段配置成默认格式以外的格式，添加添加一个postings_format的属性，将所选择信息格式的名字作为值，下面是一个例子：</p>
<pre><code>{
  "mappings":{
      "post":{
          “properties”：{
              “id”：{“type”：“long”，“store”：“yes”，“precision_step”：“<span class="operator">0”,<span class="string">"postings_format"</span>:<span class="string">"pulsing"</span>}，
              “<span class="keyword">name</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">string</span>”，“<span class="keyword">store</span>”：“yes”，“<span class="keyword">index</span>”：“analyzed”,<span class="string">"similarity"</span>:<span class="string">"BM25"</span>}，
              “published”：{“<span class="keyword">type</span>”：“<span class="built_in">date</span>”，“<span class="keyword">store</span>”：“yes”，“precision_step”：“<span class="number">0</span>”}，
              “<span class="keyword">contents</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">long</span>”，“<span class="keyword">store</span>”：“<span class="keyword">no</span>”，“<span class="keyword">index</span>”：“analyzed”,<span class="string">"similarity"</span>:<span class="string">"BM25"</span>}
              }
          }
    }
  }</span>
</code></pre></li>
<li><p>文档值格式是Lucene4.0引入的另一个新功能。它允许定义一个给定的字段，这个字段的值被写入一个具有较高内存效率的列式结构，以便进行高效的排序和切面搜索。使用了文档值的字段将有专属的字段数据缓存实，无需像标准字段一样倒排。因此，它全名索引刷新操作速度更快，让你可以在磁盘上存储字段。如增加个投票字段,并且希望对它进行排序。因为需求排序，所以就很适合使用文档值。示例(doc_values_format)：</p>
<pre><code>{
    "mappings":{
        "post":{
            “properties”：{
                “id”：{“type”：“long”，“store”：“yes”，“precision_step”：“<span class="operator">0”,<span class="string">"postings_format"</span>:<span class="string">"pulsing"</span>}，
                “<span class="keyword">name</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">string</span>”，“<span class="keyword">store</span>”：“yes”，“<span class="keyword">index</span>”：“analyzed”,<span class="string">"similarity"</span>:<span class="string">"BM25"</span>}，
                “published”：{“<span class="keyword">type</span>”：“<span class="built_in">date</span>”，“<span class="keyword">store</span>”：“yes”，“precision_step”：“<span class="number">0</span>”}，
                “<span class="keyword">contents</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">long</span>”，“<span class="keyword">store</span>”：“<span class="keyword">no</span>”，“<span class="keyword">index</span>”：“analyzed”,<span class="string">"similarity"</span>:<span class="string">"BM25"</span>},
              “votes”：{“<span class="keyword">type</span>”：“<span class="built_in">integer</span>”，<span class="string">"doc_values_format"</span>:<span class="string">"memory"</span>}
                }
            }
      }
    }</span>
</code></pre><p> 目前doc_values_format属性共有以下三个值：</p>
<ul>
<li>default:当未指定任何格式时，使用此默认格式。此格式使用少量内存而且性能良好。</li>
<li>disk：此文档值格式将数据存入磁盘，几乎无需内存。然而，在执行切面和排序操作时，性能略有降低。需要执行切面或排序操作，而又苦恼于内存空间时，可使用此格式。</li>
<li>memory：此文档格式将数据存入内存。在这种格式中，切面或排序的功能与标准倒排索引字段的功能不相上下。由于这种数据结构存储于内存中，索引的刷新速度更快，而这对快速更改索引及缩短索引更频率很有帮助。</li>
</ul>
</li>
<li><p>为索引批量添加数据：ES可以合并多个请求至单个包中，然后这些包可以单个请求的形式传达，所以，可以将如下操作结合起来：</p>
<ul>
<li>在索引中增加或更换现有文档</li>
<li>从索引中移除文档</li>
<li><p>当索引不存在其他文档定义时，在索引中增加新文档。<br>为了达到如上的需求，格式为：第一行是包含描述操作说明的JSON对象，第二行是JSON对象本身。唯一的例外是delete操作，它只包含信息行。例子如下：</p>
<pre><code>{"<span class="attribute">index</span>":<span class="value">{"<span class="attribute">_index</span>":<span class="value"><span class="string">"addr"</span></span>,"<span class="attribute">_type</span>":<span class="value"><span class="string">"contact"</span></span>,"<span class="attribute">_id</span>":<span class="value"><span class="number">1</span></span>}</span>}
{"<span class="attribute">name</span>":<span class="value"><span class="string">"Fyodor Dostoevsky"</span></span>,"<span class="attribute">country</span>":<span class="value"><span class="string">"RU"</span></span>}
{"<span class="attribute">create</span>":<span class="value">{"<span class="attribute">_index</span>":<span class="value"><span class="string">"addr"</span></span>,"<span class="attribute">_type</span>":<span class="value"><span class="string">"contact"</span></span>,"<span class="attribute">_id</span>":<span class="value"><span class="number">2</span></span>}</span>}
{"<span class="attribute">name</span>":<span class="value"><span class="string">"Erich Maria Remarque"</span></span>,"<span class="attribute">country</span>":<span class="value"><span class="string">"DE"</span></span>}
{"<span class="attribute">create</span>":<span class="value">{"<span class="attribute">_index</span>":<span class="value"><span class="string">"addr"</span></span>,"<span class="attribute">_type</span>":<span class="value"><span class="string">"contact"</span></span>,"<span class="attribute">_id</span>":<span class="value"><span class="number">2</span></span>}</span>}
{"<span class="attribute">name</span>":<span class="value"><span class="string">"Joseph Heller"</span></span>,"<span class="attribute">country</span>":<span class="value"><span class="string">"US"</span></span>}
{"<span class="attribute">delete</span>":<span class="value">{"<span class="attribute">_index</span>":<span class="value"><span class="string">"addr"</span></span>,"<span class="attribute">_type</span>":<span class="value"><span class="string">"contact"</span></span>,"<span class="attribute">_id</span>":<span class="value"><span class="number">4</span></span>}</span>}
{"<span class="attribute">delete</span>":<span class="value">{"<span class="attribute">_index</span>":<span class="value"><span class="string">"addr"</span></span>,"<span class="attribute">_type</span>":<span class="value"><span class="string">"contact"</span></span>,"<span class="attribute">_id</span>":<span class="value"><span class="number">1</span></span>}</span>}
</code></pre><p>重要的是，每一个文档或操作说明放置在一行中（以换行符结束），这意味着无法美化文档格式，批量索引文件的大小存在限制，它被设定为100M。这个属性在配置文件中的<code>http.max_content_length</code>属性来改变。</p>
</li>
</ul>
</li>
<li><p>为了执行批量请求，ES提供了<code>_bulk</code>端点，形式可以是<code>/_bulk</code>,也可以是<code>/index_name/_bulk</code>,甚至是<code>/index_name/type_name/_bulk</code>，在第二种和第三种形式定义了索引名称和类型名称的默认值。可以在请求的信息中省略这些属性，ES将使用默认值。运行上边这个JSON文件的命令如下：<br> <code>curl -XPOST &#39;localhost:9200/_bulk?pretty&#39; --data-binary @documents.json</code><br> 注意，在这个命令中，没有使用<code>-d</code>，而是使用了<code>--data-binary</code>参数，这是因为不能忽略换行符。<br> 如果想更快，可以用UDP的批量操作，请注意，使用UDP并不能保证数据包是否会丢失，所以，只在在性能比精确度更重要时，并且要索引全部的文档时，才考虑用它。</p>
</li>
<li><p>用附加的内部信息扩展索引结构，这些字段类型应定义在适当的类型级别上，它们不是索引范围内的类型。</p>
</li>
<li><p>ES索引中的每个字段都有自已的标识符和类型，在ES内中，文档存在两种标识符：</p>
<ul>
<li><code>_uid</code>字段它是索引文档中的唯一标识符，由该文档的标识符和文档类型构成。也就是说，同一个索引中，不同类型的文档可能有相同的标识符。此字段不需要额外设置，总是被索引，是自动的。</li>
<li>_id字段，此字段存储着过索引时设置的实际标识符。为了使<code>_id</code>字段能够被索引/存储，需要在映射文件中像设置其他属性一样添加_id字段的含义。一个指明希望_id字段不经分析但要编入索引，而且不希望存储的例子：<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_id"</span>:<span class="collection">{
            <span class="string">"index"</span>:<span class="string">"not_analyzed"</span>,
            <span class="string">"store"</span>:<span class="string">"no"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre>除了在索引时间指定标识符，也可从索引文档的一个字段中获取标识识（需要额外解析，比较慢）。为此，需要设定path属性，将将它的值设置为一个字段名称，该字段的值将作为标识符。如将<code>book_id</code>的值作为指定标识符的值：<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_id"</span>:<span class="collection">{
            <span class="string">"path"</span>:<span class="string">"book_id"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre>当禁用_id字段时，所有需要文档唯一标识符的功能都能继续工作。</li>
</ul>
</li>
<li><p>_type：由于每个文档至少需要它的标识符和类型来描述，默认情况下，文档的类型会编入索引，但不会被分析及存储。如果想存储，可以按如下方式修改：</p>
<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_type"</span>:<span class="collection">{
            <span class="string">"store"</span>:<span class="string">"yes"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre><p>也可改成不索引_type字段，但是如果这样，一些查询（词条查询）和过滤器将失效。</p>
</li>
<li><p>_all字段：它用来存储其他字段中的数据以便于搜索。当要执行简单搜索功能，搜索所有数据（或复制到_all字段的所有字段），又不想考虑字段名称之类的事件，这个字段很有用。它默认是启用的，包含了索此中所有字段的所有数据，这使得索引有点大，且不必要，可以完全禁它或排除某些字段，排除特字字段使用<code>include_in_all</code>属性。要完全关闭_all字段功能，可修改映射文件，如下：</p>
<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_all"</span>:<span class="collection">{
            <span class="string">"enabled"</span>:<span class="string">"false"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre><p>除了<code>enabled</code>属性，_all字段还支持以下属性：<code>store</code>、<code>term_vector</code>、<code>analyzer</code>、<code>index_analyzer</code>、<code>search_analyzer</code>,这些属性的具体意思，可向上参阅。</p>
</li>
<li><p>_source字段可以在生成索引的过程中存储发送到Elasticsearch的原始JSON文档。默认情况下，_Source字段会被开启，因为部分ES的功能依赖于这个字段（如局部更新功能）。此外，当字段没有存储时，_source字段可用作高亮功能的数据源。如果不需要，可以禁用。方式如下：</p>
<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_source"</span>:<span class="collection">{
            <span class="string">"enabled"</span>:<span class="string">"false"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre><p>如果只想包含某些字段或排除某些字段，可以使用<code>includes</code>或<code>excludes</code>属性来实现。下面是一个排除的例子：</p>
<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_source"</span>:<span class="collection">{
            <span class="string">"excludes"</span>:<span class="collection">[<span class="string">"author.*"</span>]</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre></li>
<li><p>_index字段:ES允许我们存储文档相关的索引信息，可以通过内部的_index字段做到这一点。它可以帮助我们确定文档源自那个索引。默认情况下，_index字段是禁用的。启用方式如下：</p>
<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_index"</span>:<span class="collection">{
            <span class="string">"enabled"</span>:<span class="string">"true"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre></li>
<li><p>默认情况下，_size字段未启动，这使我们能够自动索引_source字段的原始大小，与并文件一起存储。下面是一个在映射文件中把_size字段启用并存储的例子：</p>
<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_size"</span>:<span class="collection">{
            <span class="string">"enabled"</span>:<span class="string">"true"</span>,
            <span class="string">"store"</span>:<span class="string">"yes"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre></li>
<li>默认情况下，禁用的_timestamp字段允许文档在被索引时存储。默认_timestamp字段未经分析编入索引，不保存。它和普通日期字段一样，因而可以像处理普通字段一样改变它的格式。另外，它还可以添加path属性，并将其设置为某字段的名称来获取日期，而不是在文件检索过程中自动创建_timestamp字段。<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_timestamp"</span>:<span class="collection">{
            <span class="string">"enabled"</span>:<span class="string">"true"</span>,
            <span class="string">"path"</span>:<span class="string">"year"</span>,
            <span class="string">"format"</span>:<span class="string">"YYYY"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre>如果使用本字段，且让ES自动创建它，则该字段的值会被设置为文档索引的时间。但是，局部文档更新时，该字段也将被更新。</li>
<li>_ttl（time to live）生存时间，它允许定义文档的生命周期，周期结束之后文档会被自动删除。默认情况上禁用的。启用方式如下：<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_ttl"</span>:<span class="collection">{
            <span class="string">"enabled"</span>:<span class="string">"true"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre>若要提供文件的默认过期时间，可作如下设置：<pre><code><span class="collection">{
    <span class="string">"book"</span>:<span class="collection">{
        <span class="string">"_ttl"</span>:<span class="collection">{
            <span class="string">"enabled"</span>:<span class="string">"true"</span>,
            <span class="string">"default"</span>:<span class="string">"30d"</span>
        }</span>,
        <span class="string">"properties"</span>:<span class="collection">{
            .
            .
            .
        }</span>
    }</span>
}</span>
</code></pre>默认情况下，_ttl值未经分析即存储和索引。可以改变这两个参数，但是记住这两个参数要未经分析才能工作。</li>
<li>段合并：由于Lucene库及ES中一旦数据被写入，说不再改变。所以删除需要额外记录，以应用到搜索过程中。段合并，就底层的lucene库获取若干段，并在这些信息的基础上创建一个新的段，然后将原来的段在磁盘上删除。这是因为段合并在CPU和I/O的使用方面代价是相当高的，所以要适当的控制这个过程被调用的机率。</li>
<li><p>段合并策略</p>
<ul>
<li>tiered：默认合并策略，合并尺寸大致相似的段，并考虑到每个层允许的最大段数量。</li>
<li>log_byte_size:随着时间的推移，将产生由索引大小的对数构成的索引，基中存在着一些较大的段及一些合并因子较小的段。</li>
<li>log_doc:类似log_byte_size,但根据索引中的文档数而非段的实际字节数来操作。</li>
</ul>
<p>可使用index.merge.policy.type属性来设置想使用的合并策略。<code>index.merge.policy.type:tiered</code>,当然，这个值在索引创建后无法再修改。</p>
</li>
<li>合并调度器指示ES合并过程的方式，有如下两种可能：<ul>
<li>并发合并调度器，这是默认的合并过程，在独立的线程中执行，定义好的线程数量可以并行合并。</li>
<li>串行合并调度器：这一合并过程在调用线程（即执行索引的线程）中执行。合并进程会一直阻塞线程直到合并完成。<br>调度器可使用index.merge.scheduler.type参数设置，若要使用串行合并调度器，需设置值为serial;并行为concurrent。<code>index.merge.scheduler.type:concurrent</code></li>
</ul>
</li>
<li><p>合并因子指定了索引过程中段合并的频率。因子较小，搜索的速度更快，占用的内存也更少，但索引的速度会变慢；合并因子大时，则索引速度加快，这是因为发生的合并少，但搜索的速度慢，占用的内存也大。对于log_byte_size和log_doc合并策略，可通过<code>index.merge.policy.merge_factor</code>参数来设置合并因子。它的默认值是10,建议在批量索引时设置更高的值，普通的索引维护则设置较低的属性值。<code>index.merge.policy.merge_factor:10</code></p>
</li>
<li><p>调节：由于合并时可能会严重影响性能，所以调节可能会改变这一状况。它即可以限制合并的速度，也可以使用数据存储的所有操作。这个参数可以通过配置文件中配置，也可以动态通过api来设置。它有两个设置：</p>
<ul>
<li>indices.store.throttle.type:none,不打开；merge：该值定义调节仅在合并过程中有效；all：该值定义调节在所有数据存储过程中有效。</li>
<li>indices.store.throttle.max_bytes_per_sec:10mb。限制合并操作为每秒10M。默认情部分下，ES使用merge调节类型，max_bytes_per_sec属性设置为20mb。这意味着所有的合并操作都限于20M/秒。</li>
</ul>
</li>
<li><p>默认情况下，ES会在所有索引的分片中均匀地分配文档，但是，有时为了获取文档，需要查询所有分片并合并结果。如果把数据按照一定的依据来划分，就可以使用一个强大的文档和查询分布控制机制：路由。它允许选择用于索引和搜索数据的分片。</p>
</li>
<li>默认索引过程：发送文档旮，ES会计算文档标识符的散列值，以此为基础将文档放置于一个可用的主分片上。然后，这些文档被重新分配置副本。</li>
<li>默认搜索过程：查询发送到ES的一个节点，ES将会根据搜索类型来搪行查询。它首先查询所有节点得到标识符和匹配文档的得分，接着发送一个内部查询，但仅发送到相关的分片（包含文档的分片），最后获取所需文档来构建响应。</li>
<li>路由可以控制文档和查询转发的目的分片。可以在索引和查询时都指定路由值。如，索引时使用userId值来设置路由，在搜索时也一样。由于userId值一样，计算出的散列值是相同的，因而特定用户的所有文档将被放置在相同的分片中，这样，在搜索中使用相同的属性值，则只需搜索单个分片而不是整个索引。<br>使用路由时，仍然应该为路由值相同的值添加一个过滤器。因为路由值的数量或许比索引分片的数量多。因此，一些不同的属性值可以指向相同的分片，如果忽略过滤，得到的数据并非是路由的单个值，而是特定分片驻留的所有路由值。</li>
<li>最简单的方法是使用路由参数来提供路由值。索引或查询时，可以添加路由参数到HTTP，或使用你所选择的客户端来设置。示例如下：<br>添加文档：<pre><code>curl -XPUT <span class="string">'http</span>:<span class="comment">//localhost://9200/posts/post/1?routing=12' -d '{</span>
    <span class="string">"id"</span>:<span class="number">1</span>,
    <span class="string">"name"</span>:<span class="string">"Test Document"</span>,
    <span class="string">"contents"</span>:<span class="string">"Test document"</span>,
    <span class="string">"userId"</span>:<span class="number">12</span>
}'
</code></pre>查询例子：<pre><code><span class="title">curl</span> -XGET <span class="string">'http://localhost:9200/posts/_search?routing=12&amp;q=userId:12'</span>
</code></pre>可以看到，索引和查询需要使用相同的值。如果指定了多个路由值，并由逗号分隔开来。如果还想在查询中使用section参数来路由，并根据这个参数过滤，查询将会如下所示：<pre><code><span class="title">curl</span> -XGET <span class="string">'http://localhost:9200/posts/_search?routing=12,6654&amp;q=userId:12+AND+section:6654'</span>
</code></pre>为每个发送到ES的请求指定路由值并不方便。所以在索引过程中，ES允许指定一个字段，用该字段的值作为路由值，这样只需要在查询时提供路由参数。指定示例如下：<pre><code><span class="string">"_routing"</span><span class="symbol">:</span>{
    <span class="string">"required"</span><span class="symbol">:true</span>,
    <span class="string">"path"</span><span class="symbol">:userId</span>
}
</code></pre>上边意思是说查询时必须提供路由器，否则索引请求将失败。path用来指定文档的那个字段应被设置为路由器。这意味着，每个文档userId都必须定义。但是，使用路由字段时，ES需要一些额外的解析，因此比使用路由参数时慢一些。<br>添加路由部分后的映射文件如下所示：<pre><code><span class="collection">{
<span class="string">"mappings"</span>:<span class="collection">{
    <span class="string">"post"</span>:<span class="collection">{
        <span class="string">"_routing"</span>:<span class="collection">{
            <span class="string">"required"</span><span class="attribute">:true</span>,
            <span class="string">"path"</span><span class="attribute">:userId</span>
        }</span>,
        “properties”：<span class="collection">{
            “id”：<span class="collection">{“type”：“long”，“store”：“yes”，“precision_step”：“<span class="number">0</span>”,<span class="string">"postings_format"</span>:<span class="string">"pulsing"</span>}</span>，
            “name”：<span class="collection">{“type”：“string”，“store”：“yes”，“index”：“analyzed”,<span class="string">"similarity"</span>:<span class="string">"BM25"</span>}</span>，
            “published”：<span class="collection">{“type”：“date”，“store”：“yes”，“precision_step”：“<span class="number">0</span>”}</span>，
            “contents”：<span class="collection">{“type”：“long”，“store”：“no”，“index”：“analyzed”,<span class="string">"similarity"</span>:<span class="string">"BM25"</span>}</span>,
          “votes”：<span class="collection">{“type”：“integer”，<span class="string">"doc_values_format"</span>:<span class="string">"memory"</span>}</span>
            }</span>
        }</span>
  }</span>
}</span>
</code></pre>如果想用上述映射来创建Posts索引，可以用下面的命令来为单个测试文档建立索引：<pre><code>curl -XPOST <span class="string">'localhost:9200/posts/post/1'</span> -d <span class="string">'{            
    "</span>id<span class="string">":1,
    "</span>name<span class="string">":"</span>Test Document<span class="string">",
    "</span>contents<span class="string">":"</span>Test document<span class="string">",
    "</span>userId<span class="string">":12124
}'</span>
</code></pre> 12124将作为索引时的路由值。</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-08-21T13:26:27.000Z"><a href="/2015/08/21/在批处理-bat-中设置java程序的内存参数/">2015-08-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/21/在批处理-bat-中设置java程序的内存参数/">在批处理(bat)中设置java程序的内存参数</a></h1>
  

    </header>
    <div class="entry">
      
        <p>最近做一个java的桌面程序，竟然内存溢出了。由于是将启动命令<code>java -jar XXX.jar</code>写在了批处理中,所以竟一时想不起来如何设置程序运行参数了。以前是天天在eclipse的开发环境中设置，在tomcat的启动批处理中设置，在各种开源软件的启动脚本中设置，可是要在这么的一个简单命令中设置，竟然失忆了，不会了。。。<br>于是乎，百度了一番，才猛然间想了起来，原来，如此简单，添加后的示例如下，权当记录一下，谨防以后再忘记吧。</p>
<pre><code>java  -Xms800m -Xmx800m -XX:PermSize=<span class="number">128</span>M -XX:MaxNewSize=<span class="number">256</span>m -XX:MaxPermSize=<span class="number">256</span>m  -jar  XXX.jar
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-08-16T15:38:12.000Z"><a href="/2015/08/16/《Elasticsearch服务器开发》学习笔记（二）/">2015-08-16</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/16/《Elasticsearch服务器开发》学习笔记（二）/">《Elasticsearch服务器开发》学习笔记（二）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="第2章_映射配置(一)">第2章 映射配置(一)</h2><p><strong>本系列是本人在学习《Elasticsearch服务器开发》一书中所做的读书笔记，如有读不懂的地方，请直接参考原书。建议直接购买原书，支持正版。</strong></p>
<ol>
<li>Elasticsearch是一个无模式的搜索引警,可以即时算出数据结构,但是自已控制并定义结构是更好的办法。</li>
<li>Elasticsearch是由一个或多个分片组成，每个分片包含了文档集的一部分。而且这些分片也有副本。在创建索引时，可以规定分片及副本的数量，也可以使用全局配置文件或软件内部的默认值。5个分片，1个副本，就意味着在集群中有10个lucene索引。<strong>副本可以随时调整，但是分片，则不能调整。创建好索引后更改分片的唯一图径是创建另外一个索引并重新索引数据。</strong></li>
<li>直接创建一个索引<code>curl -XPUT http://localhost:9200/blog</code>。不让它自动创建索引是因为有时候要修改分片数目、设置索引结构。因此，可以关闭配置文件中自动创建索引的配置<code>action.auto_create_index:-an*,+a,-*</code>,上面的命令意思是说不允许自动创建以<code>an</code>开头的索引；允许自动创建以<code>a</code>开头的索引，其他的索引也必须手工创建。</li>
<li>一个手工设置分片及副本数量的例子<code>curl -XPUT http://localhost:9200/blog/ -d &#39;{&quot;settings&quot;:{&quot;number_of_shards&quot;:1,&quot;number_of_replicas&quot;:2}}&#39;</code></li>
<li>删除索引<code>curl -XDELETE http://localhost:9200/posts</code></li>
<li><p>映射类似于关系数据库的数据结构。在定义映射时，Elasticsearch可以通过定义的JSON来猜测文档结构。在JSON中，字符串用引号括起来，布尔值用特定的词语定义，数值则是数字。但是，有时ES也会忽略数字类型，全按字符串来处理。可以使用如下命令来强制它进行文本检测。</p>
<pre><code>curl -XPUT <span class="string">http:</span><span class="comment">//localhost:9200/blog/ -d '{</span>
    <span class="string">"mappings"</span>:{
        <span class="string">"article"</span>:{
            “numberic_detection”:<span class="literal">true</span>
            }
      }
 }
</code></pre><p> 但是，此时仍然不能猜出布尔型。在这种情况下，如果无法改变数据格式，只能在映射中定义字段。<br> 还有日期类型，ES设法识别被提供的时间戳或与日期格式匹配的字符串，还可以使用dynamic_date_formats属性定义可被识别的日期格式列表，该属性允许指定一个数组，如下：</p>
<pre><code>curl -XPUT http:<span class="comment">//localhost:9200/blog/ -d '{</span>
    <span class="string">"mappings"</span>:{
        <span class="string">"article"</span>:{
            “<span class="keyword">dynamic</span><span class="number">_</span>date<span class="number">_f</span>ormate”:[<span class="string">"yyyy-MM-dd hh:mm"</span>]
            }
      }
 }
</code></pre><p> 上面这段定义了一个叫<code>blog</code>的索引，它包括一个名为<code>article</code>的类型，它是日期型的，只识别固定的格式。ES使用<code>joda-time</code>库定义日期格式</p>
<p> 为了避免不必要的错误，最好关闭自动识别类型。如同一类型，一个是整型，一个是浮点数，如果先接触到整型，则可能猜成整型，后面的就会丢失小数部分。关闭命令如下：</p>
<pre><code>curl -XPUT http:<span class="comment">//localhost:9200/blog/ -d '{</span>
    <span class="string">"mappings"</span>:{
        <span class="string">"article"</span>:{
            “dynamic”:“<span class="keyword">false</span>”，
            “properties”：{
                “id”：{“<span class="class"><span class="keyword">type</span>”：“<span class="title">string</span>”}，</span>
                “content”：{“<span class="class"><span class="keyword">type</span>”：“<span class="title">string</span>”}，</span>
                “author”：{“<span class="class"><span class="keyword">type</span>”：“<span class="title">string</span>”}</span>
                }
            }
      }
 }'
</code></pre><p> properties即为定义的字段，<strong>如果传入数据时，还传入了其它字段，则ES会自动忽略。</strong></p>
</li>
<li><p>在ES中，映射可以定义在文件中，以JSON对象的方式传送。新建一A.json文件，内容如下：</p>
<pre><code>{
   "mappings":{
       "post":{
           “properties”：{
               “id”：{“type”：“long”，“store”：“yes”，“precision_step”：“<span class="operator">0”}，
               “<span class="keyword">name</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">string</span>”，“<span class="keyword">store</span>”：“yes”，“<span class="keyword">index</span>”：“analyzed”}，
               “published”：{“<span class="keyword">type</span>”：“<span class="built_in">date</span>”，“<span class="keyword">store</span>”：“yes”，“precision_step”：“<span class="number">0</span>”}，
               “<span class="keyword">contents</span>”：{“<span class="keyword">type</span>”：“<span class="keyword">long</span>”，“<span class="keyword">store</span>”：“<span class="keyword">no</span>”，“<span class="keyword">index</span>”：“analyzed”}
               }
           }
     }
}</span>
</code></pre><p> 建立好文件后，就可以执行了：<code>curl -XPOST &#39;http://localhost:9200/posts&#39; -d @A.json</code></p>
</li>
<li><p>每个字段类型可以指定为ES提供的一个特定核心类型型。ES有以下特定核心类型</p>
<ul>
<li>string：字符串</li>
<li>number：数字</li>
<li>date：日期</li>
<li>boolean：布尔型</li>
<li>binary：二进制。</li>
</ul>
</li>
<li><p>数值字段类型：</p>
<ul>
<li>byte:字节值，例如1</li>
<li>short:短整型值，如12</li>
<li>integer：整型值，如134</li>
<li>long：长整型值，如：123456789</li>
<li>float：浮点型，如：12.23</li>
<li>double：双精度，如：123.45</li>
</ul>
</li>
<li><p>公共属性</p>
<ul>
<li>index_name:存储在索引中的字段名称，若未定义，则存储对象的名字。</li>
<li>index：属性为analyzed：该字段将被编入索引以供搜索，这也是默认值；no则无法搜索该字段，而且此时include_in_all属性无效；not_analyzed:意味着字段不经分析而编入索引，也就是说不分词，全部匹配。</li>
<li>store：yes指定该字段原始值写入到索引中，默认为no，默认值意味着在结果中不能返回该字段，该值编入了索引，就可基于它来搜索数据。如果使用_source字段，即使没有存储也可返回这个值。</li>
<li>boost：该属性的默认值是1。定义了字段的重要性，值越高，重要性越大。</li>
<li>null_value:该字段并非索引文档的一部分，此属性指定写入索引的值。默认的行为是忽略该字段。</li>
<li>copy_to:此属性指定一个字段，字段的所有值都将复制到该指定字段。</li>
<li>include_in_all:此属性指定该字段是否应包括在_all字段中。默认情况下，如果使用_all字段，所有的字段都会包括在其中。</li>
</ul>
</li>
<li><p>字符串属性，对于字符串，除了以上公共属性，还有许多额外的属性。</p>
<ul>
<li>term_vector:默认为no，还可以设为yes、with_offsets、with_positions及with_positions_offsets。它定义是计算该字段的Lucenne词向量，如果要使用高亮功能，就需要计算词向量。</li>
<li>omit_norms:对于经过分析的字段，默认为false；未经过分析但已编入索引的字符串字段，为true。为true时，会禁用Lucene对该字段进行加权基准计算，这样就无法使用索引期间的加权，从而为只用于过滤器中字段节省内存。</li>
<li>analyzer：该属性用于定义索引和搜索的分析器名称。默认为全局定义的分析器名称。</li>
<li>index_analyzer:该属性定义用于建立索引的分析器的名称。</li>
<li>search_ayalyzer:该属性用于定义搜索的分析器名称。</li>
<li>norms.enabled:指定是否为字段加载加权基准。默认情况下，为已分析字段设置为true，未分析字段设置为false。</li>
<li>norms.loading:eager表示此字段总是载入加权基准，lazy表示需要时再加载。</li>
<li>position_offset_gap:默认为0。指定索引中在不同的实例中具有相同名称的字段的差距。如基于位置的，若只想查出一个字段，可以设得较高点。</li>
<li>index_options:定义了信息列表的索引选项。<code>docs</code>:仅对文档编号建立索引；<code>freqs</code>：对文档编号和词频建立索引；<code>positions</code>：对文档编号、词频和它们的位置建立索引；<code>offsets</code>对文档编号、词频、位置和偏移量进行索引。对于经分析的字段，默认值是<code>positions</code>;未经分析的字段，默认值是<code>docs</code>。</li>
<li>ignore_above：定义字段中字符的最大值，当字段的长度高于指定值时，分析器会将其忽略。</li>
</ul>
</li>
<li><p>数值属性，除了公共属性，数值还有如下属性：</p>
<ul>
<li>precision_step:指定为某个字段中的每个值生成的词条数。值越底，产生的词条数越高。对于每个值的词条数更高的字段，范围查询会更快，但索引会更大点。默认址是4。</li>
<li>ignore_malformed：此属性为true时，忽略格式错误的值；false不忽略。</li>
</ul>
</li>
<li><p>布尔型：<code>&quot;allowed&quot;:{&quot;type&quot;:&quot;boolean&quot;,&quot;store&quot;:&quot;yes&quot;}</code></p>
</li>
<li><p>二进制：该字段用Base64表示，可以用来存储二进制形式正常写入的数据，如图像。它只能被存储，不能被索引，不能搜索。它只支持index_name属性。基于binary字段的定义示例如下：<code>&quot;allowed&quot;:{&quot;type&quot;:&quot;binary&quot;}</code></p>
</li>
<li><p>日期：默认使用UTC保存，它允许指定时间，也允许指定日期。如<code>2012-12-24T12:10:22</code>,示例如下：<code>&quot;published&quot;:{“type”:&quot;date&quot;,&quot;store&quot;:&quot;yes&quot;,&quot;format&quot;:&quot;YYYY-mm-dd&quot;}</code>。除了公共属性，它的主要属性有：</p>
<ul>
<li>format，默认值为：<code>dateOptionalTime</code>。</li>
<li>precision_step:指定为某个字段中的每个值生成的词条数。值越底，产生的词条数越高。对于每个值的词条数更高的字段，范围查询会更快，但索引会更大点。默认址是4。</li>
<li>ignore_malformed：此属性为true时，忽略格式错误的值；false不忽略。</li>
</ul>
</li>
<li><p>多字段：有时候希望两个字段中有相同的字段值，如一个用来搜索，一个用于排序或一个经语言分析器分析、一个只基于空白字符分析。ES允许加入多字段对象来实现。下面是一个例子：</p>
<pre><code><span class="string">"name"</span>:{
    <span class="string">"type"</span>:<span class="string">"string"</span>,
        <span class="string">"fields"</span>：{
          <span class="string">"facet"</span>:{<span class="string">"type"</span>:<span class="string">"string"</span>,<span class="string">"index"</span>:<span class="string">"not_analyzed"</span>}
        }
  }
</code></pre><p>上面的代码创建了两个字段一个是”name”,一个是”name.facet”。在索引中不必指定两个字段，只指定一个name就够了。ES会自动将该字段的数值复制到多字段定义的所有字段中。</p>
</li>
<li><p>IP地址类型：下面是一个例子：<code>&quot;address&quot;:{&quot;type&quot;:&quot;ip&quot;,&quot;store&quot;:&quot;yes&quot;}</code>,IP类型还有一人额外的属性：</p>
<ul>
<li>precision_step:指定为某个字段中的每个值生成的词条数。值越底，产生的词条数越高。对于每个值的词条数更高的字段，范围查询会更快，但索引会更大点。默认址是4。</li>
</ul>
</li>
<li><p>token_count类型：允许存储有关索引的字数信息，而不是存储及检索该字段的文本。它接受与number类型相同的配置选项，还可以用analyzer属性来指定分析器。例子<code>&quot;address_count&quot;:{&quot;type&quot;:&quot;token_count&quot;,&quot;store&quot;:&quot;yes&quot;}</code></p>
</li>
<li><p>对于字符串，可以指定使用的分析器，分析器是一个用于分析数据或以我们想要的方式查询数据的工具。ES使我们能够在索引和查询时使用不同的分析器，并且可以在使搜索过程中的每个阶段选择处理数据的方式。ES默认带了若干分析器，如下的分析器开箱即用：</p>
<ul>
<li>standard:方便大多数欧洲语言的标准分析器。</li>
<li>simple:这个分析器基于非字母字符来分离所提供的值，并将其转换为小写形式。</li>
<li>whitespace:这个分析器基于空白字符来分离所提供的值。</li>
<li>stop:类似于simple，除了simple的功能，还能基于所提供的停用词过滤数据。</li>
<li>keyword:只传入提供的值。可以通过指定字段为not_analyzed来达到相同的目的。</li>
<li>pattern:通过正则表达式灵活的分离文本。</li>
<li>language:这个分析器旨在特定的语言环境下工作。</li>
<li>snowball:类似于standard分析器，但提供了词干提取算法。</li>
</ul>
</li>
<li><p>自定义分析器。ES允话自定义分析器，无需编写java代码。自定义分析器需要在配置文件中新增setting节点，示例代码如下：</p>
<pre><code><span class="string">"settings"</span>:{
    <span class="string">"index"</span>:{
        <span class="string">"analysis"</span>:{
          <span class="string">"analyzer"</span>:{
            <span class="string">"en"</span>:{
                <span class="string">"tokenizer"</span>:“standard”，
                <span class="string">"filter"</span>：[
                  <span class="string">"asciifolding"</span>,
                  <span class="string">"lowercase"</span>,
                  <span class="string">"ourEnglishFilter"</span>
                  ]
                }
            },
            <span class="string">"filter"</span>：{
              <span class="string">"ourEnglishFilter"</span>:{
                <span class="string">"type"</span>:<span class="string">"kstem"</span>
              }
          }
      }
 }
</code></pre><p>上例中指定一个新的名为<code>en</code>的分析器。每个分析器由一个分词器和多个过滤器构成。默认过滤器和分词器完整列表参见官方文档。我们的<code>en</code>分析器包括standard分词器和三个过滤器：默认情况下可用asciifolding、lowercase，以及一个自定义的ourEnglishFilter。要想自定义过滤器，需要提供它的名称、类型以及该过滤器类型所需要的任意数量的附加参数。所以最终版本如下：</p>
<pre><code> <span class="collection">{
 <span class="string">"settings"</span>:<span class="collection">{
     <span class="string">"index"</span>:<span class="collection">{
         <span class="string">"analysis"</span>:<span class="collection">{
           <span class="string">"analyzer"</span>:<span class="collection">{
             <span class="string">"en"</span>:<span class="collection">{
                 <span class="string">"tokenizer"</span>:“standard”，
                 <span class="string">"filter"</span>：<span class="collection">[
                   <span class="string">"asciifolding"</span>,
                   <span class="string">"lowercase"</span>,
                   <span class="string">"ourEnglishFilter"</span>
                   ]</span>
                 }</span>
             }</span>,
             <span class="string">"filter"</span>：<span class="collection">{
               <span class="string">"ourEnglishFilter"</span>:<span class="collection">{
                 <span class="string">"type"</span>:<span class="string">"kstem"</span>
               }</span>
           }</span>
       }</span>
  }</span>
}</span>,
<span class="string">"mappings"</span>：<span class="collection">{
  <span class="string">"post"</span>:<span class="collection">{
    <span class="string">"properties"</span>:<span class="collection">{
      <span class="string">"id"</span>:<span class="collection">{<span class="string">"type"</span>:<span class="string">"long"</span>,<span class="string">"store"</span>:<span class="string">"yes"</span>,<span class="string">"precision_step"</span>:<span class="string">"0"</span>}</span>,
      <span class="string">"name"</span>:<span class="collection">{<span class="string">"type"</span>:<span class="string">"string"</span>,<span class="string">"store"</span>:<span class="string">"yes"</span>,<span class="string">"index"</span>:<span class="string">"analyzed"</span>,<span class="string">"analyzer"</span>:<span class="string">"en"</span>}</span>
    }</span>
  }</span>
}</span></span>
</code></pre></li>
<li><p>要求ES展示为Post类型和它的name字段定义的分析器对指定短语的分析内容：<code>curl -XGET &#39;localhost:9200/posts/_analyze?pretty&amp;field=post.name&#39; -d &#39;robots cars&#39;</code></p>
</li>
<li><p>分析器字段：可以用分析器字段(_analyzer)来指定一个字段，该字段的值将作为字段所属文档的分析器名称。应该定义一个与下列language字段中提供的值一样的分析器，否则会索引失败。示例如下：</p>
<pre><code>{
  "<span class="attribute">mappings</span>":<span class="value">{
    "<span class="attribute">post</span>":<span class="value">{
      "<span class="attribute">_analyzer</span>":<span class="value">{
          "<span class="attribute">path</span>":<span class="value">“language”
          </span>}，
          <span class="string">"properties"</span>：{
            "<span class="attribute">id</span>":<span class="value">{"<span class="attribute">type</span>":<span class="value"><span class="string">"long"</span></span>,"<span class="attribute">store</span>":<span class="value"><span class="string">"yes"</span></span>,"<span class="attribute">precision_step</span>":<span class="value"><span class="string">"0"</span></span>}</span>,
            "<span class="attribute">name</span>":<span class="value">{"<span class="attribute">type</span>":<span class="value"><span class="string">"string"</span></span>,"<span class="attribute">store</span>":<span class="value"><span class="string">"yes"</span></span>,"<span class="attribute">index</span>":<span class="value"><span class="string">"analyzed"</span></span>}</span>,
            "<span class="attribute">language</span>":<span class="value">{"<span class="attribute">type</span>":<span class="value"><span class="string">"string"</span></span>,"<span class="attribute">store</span>":<span class="value"><span class="string">"yes"</span></span>,"<span class="attribute">index</span>":<span class="value"><span class="string">"not_analyzed"</span></span>}
             </span>}
          </span>}
      </span>}
</span>}
</code></pre></li>
<li><p>在没有定义分析器的情况下，应指定在默认情况下使用的分析器。这与在眏射文件中的setting部分配置自定义分析器的方式相同，但应使用default关键字来命令。因此，为了把前面的自定义分析器作为默认的分析器，可以将en分析器修改为下面这样：</p>
<pre><code><span class="collection">{
<span class="string">"settings"</span>:<span class="collection">{
    <span class="string">"index"</span>:<span class="collection">{
        <span class="string">"analysis"</span>:<span class="collection">{
          <span class="string">"analyzer"</span>:<span class="collection">{
            <span class="string">"default"</span>:<span class="collection">{
                <span class="string">"tokenizer"</span>:“standard”，
                <span class="string">"filter"</span>：<span class="collection">[
                  <span class="string">"asciifolding"</span>,
                  <span class="string">"lowercase"</span>,
                  <span class="string">"ourEnglishFilter"</span>
                  ]</span>
                }</span>
            }</span>,
            <span class="string">"filter"</span>：<span class="collection">{
              <span class="string">"ourEnglishFilter"</span>:<span class="collection">{
                <span class="string">"type"</span>:<span class="string">"kstem"</span>
               }</span>
            }</span>
        }</span>
      }</span>
   }</span>
}</span>
</code></pre></li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-08-10T14:59:45.000Z"><a href="/2015/08/10/Linux折腾记(1)-CentOS7下安装mysql数据库/">2015-08-10</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/10/Linux折腾记(1)-CentOS7下安装mysql数据库/">Linux折腾记(1)-CentOS7下安装mysql数据库</a></h1>
  

    </header>
    <div class="entry">
      
        <p>最近几天在CentOS7下安装mysql数据，折腾了好几天，问遍了度娘和谷歌，发现同样的错误是不少，但解决方案多种多样。很可惜，这么多方案我始终没有调试成功。最终，去官网上扒拉了一番洋文，找到了一种正确的步骤，才得以安装成功，现记录如下：</p>
<h2 id="#清理">#清理</h2><p>折腾了这么久了，还是先把之前的环境给清理干净吧：</p>
<ol>
<li><p>先查询mysql相关的软件包，使用如下命令：</p>
<pre><code>[root@localhost 桌面]<span class="preprocessor"># rpm -qa|grep mysql</span>
mysql-community-common-<span class="number">5.6</span><span class="number">.26</span>-<span class="number">2.</span>el7.x86_64  
mysql-community-release-el7-<span class="number">5.</span>noarch  
</code></pre></li>
<li><p>可以看到我的机器上有两个相关的包，使用下面的命令依次删除：</p>
<pre><code>yum remove mysql-community-common<span class="class">.x86_64</span>
yum remove mysql-community-release-el7-<span class="number">5</span><span class="class">.noarch</span>  
</code></pre></li>
<li><p>清理其它目录：</p>
<pre><code><span class="keyword">cd</span> /<span class="keyword">var</span>/lib &amp;&amp; <span class="keyword">rm</span> -rfv mysql
</code></pre></li>
</ol>
<h2 id="#下载与安装">#下载与安装</h2><p>##方案一</p>
<ol>
<li><p>首先在<a href="http://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="external">http://dev.mysql.com/downloads/repo/yum/</a>下载对应的安装源的安装包。我是CentOS7，所以我下载的是<code>Red Hat Enterprise Linux 7 / Oracle Linux 7 (Architecture Independent), RPM Package</code>,下载地址如下：<a href="http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm" target="_blank" rel="external">http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</a>。</p>
</li>
<li><p>使用<code>rpm -ivh mysql-community-release-el7-5.noarch.rpm</code>命令安装该包。安装完成后，可以使用<code>yum repolist</code>查看下安装源，可以看到已经出现了三个mysql相关的安装源：</p>
<pre><code>      源名称                               源标识                                    状态
mysql-connectors-community/x86_64 MySQL Connectors Community                  <span class="number">14</span>
mysql-tools-community/x86_64      MySQL Tools Community                       <span class="number">19</span>
mysql56-community/x86_64          MySQL <span class="number">5.6</span> Community Server                 <span class="number">169</span>
</code></pre></li>
<li><p>安装mysql数据库<code>yum install mysql-server</code>。反是询问是否下载安装的，一路<code>y</code>取可。</p>
</li>
<li>启动服务<code>systemctl start mysql.service</code>,若无任何输入，则是启动成功。</li>
<li>查询mysql服务状态<code>systemctl is-active mysql.service</code>,如果启动成功，应该输出<code>active</code>。</li>
</ol>
<p>##方案二（使用MariaDB代替mysql）<br>MariaDB这货是什么东东，问度娘吧，我只知道google、维基百科、几大Linux发行版都用它替代了mysql。更重要的，现在使用MariaDB来替代mysql，客户端驱动包都不用变，更不用说需不需要改动代码了。</p>
<ol>
<li><p>如果之前装过MariaDB,依次使用如下命令清除：</p>
<pre><code>yum remove mariadb-server
<span class="keyword">cd</span> /<span class="keyword">var</span>/lib &amp;&amp; <span class="keyword">rm</span> -rfv mysql
</code></pre></li>
<li><p>使用如下命令安装<code>yum install mariadb-server</code></p>
</li>
<li><p>去除大小写敏感（一定要在建数据库之前）,在<code>/etc/my.cnf</code>中的<code>[mysqld]</code>后添加添加<code>lower_case_table_names=1</code>。0表示区分大小写，1表示不驱分，默认是0。</p>
</li>
<li><p>启动服务<code>systemctl start mariadb.service</code></p>
</li>
<li><p>查询服务状态<code>systemctl is-active mariadb.service</code></p>
</li>
</ol>
<h2 id="#修改密码并开启远程访问（mysql、MariaDB通用）">#修改密码并开启远程访问（mysql、MariaDB通用）</h2><ol>
<li><p>以管理员在命令行登录：<code>mysql -uroot</code></p>
</li>
<li><p>在命令行提示下修改密码为<code>123456</code></p>
<pre><code>MariaDB [(none)]&gt; <span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> = password(<span class="string">'123456'</span>);
</code></pre></li>
<li><p>开启远程访问：</p>
<pre><code>MariaDB [(none)]&gt; grant all privileges <span class="literal">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> identified <span class="keyword">by</span> <span class="string">'123456'</span> <span class="keyword">with</span> grant option;
</code></pre></li>
<li><p>设置为开机启动<code>systemctl enable mariadb.service</code>(MariaDB)，<code>systemctl enable mariadb.service</code>(mysql)。</p>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-08-06T07:38:12.000Z"><a href="/2015/08/06/《Elasticsearch服务器开发》学习笔记（一）/">2015-08-06</a></time>
      
      
  
    <h1 class="title"><a href="/2015/08/06/《Elasticsearch服务器开发》学习笔记（一）/">《Elasticsearch服务器开发》学习笔记（一）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="第1章_入门-知识点">第1章 入门-知识点</h2><p><strong>本系列是本人在学习《Elasticsearch服务器开发》一书中所做的读书笔记，如有读不懂的地方，请直接参考原书。建议直接购买原书，支持正版。</strong></p>
<p>1.术语</p>
<ul>
<li>文档document：索引和搜索时使用的主要数据载体，包含一个或多个存有数据的字段。</li>
<li>字段field：文档的一部分，包含名称和值两部分。</li>
<li>词term：一个搜索单元，表示文本中的一个词</li>
<li>标记token：表示在字段文本中出现的词，由这个词的文本、开始和结束偏移量以及类型组成</li>
</ul>
<p>2.Apache Luncence将所有信息写到一个称为倒排索引Inverted index的结构中。它是面向词而不是文档的。</p>
<p>3.分词的工作由分析器完成，它由一个分词器tokenizer和0个或多个标记过滤器token filter组成，也可以有0个或多个字符射器character mapper。分词的结果被称为标记流token stream，它是一个接一个的标记，准备被过滤器处理。</p>
<p>4.Lucene分析器包含零个或多个标记过滤器，用来处理标记流中的标记，如</p>
<ul>
<li>小写过滤器:把所有的标记变成小写。</li>
<li>同义词过滤器:基于基本的同义词规则，把一个标记换成另一个同义的标记。</li>
<li>多语言词干提取过滤器:减少标记，得到词根或者基本形式，即词干。</li>
</ul>
<p>过滤器是一个接一个处理的。所以我们通过使用多个过滤器，几乎可以达到无限的分析可能性。</p>
<p>字符映射器对未经分析的文本起作用，他们在分词器之前工作，因此，我们可以很容易地从文本的整体部分去除HTML标签而无需担心它们被标记。</p>
<p>5.建立索引时，Lucene会使用你选择的分析器来处理你的文档内容。不同的字段也可以使用不同的分析器，所以文档的名字字段可以和汇总字段做不同的分析。也可以不分析字段。</p>
<p>查询时，查询将被分析。但是，你也可以选择不分析。即你查询的词是否还会自动拆分匹配。</p>
<p>索引和查询词应该匹配，以返回文档。而且在索引和查询分析时，对所用标记过滤器保持相同的顺序，这样被分析出来的词是一样的。</p>
<p>6.评分:分数是根据文档和查询的匹配度用计分公式计算的结果。默认情况下，Apache Lucene使用TF/IDF(词频/逆向文档频率)评分机制。分数越高，越相关。</p>
<p>7.索引index是Elasticsearch对逻辑数据的逻辑存储，相当于关系数据库的表。索引的结构是为快速有效的全文索引准备的，特别是它不存储原始值。索引可以放在一台机器或者分散在多台服务器上，每个索引有一个或多个分片shard，每个分片可以有多个副本replica。<strong>感觉把索引理解成关系数据库的表，类型理解为表，文档理解为一行记录，更好！ by2015.08.14</strong></p>
<p>8.文档document是存储的主要实体，相当于数据库中表的一行记录。在Elasticsearch的文档中，相同字段必须有相同的类型。如所有包含title字段的文档，title字段类型都必须是一样的，比如string。</p>
<p>文档由多个字段组成，每个字段可能多次出现在一个文档里，这样的字段叫多值字段multivalued。每个字段都有类型：文本、数值和日期等。字段也可以是复杂类型。文档不需要有固定的结构，每个文档可以有不同的字段，在程序开发期间，不必确定有那些字段。每个文档存储在一个索引中并有一个Elasticsearch自动生成的唯一标识符和文档类型。文档需要有对应文档类型的唯一标识符，这意味着在一个索引中，两个不同类型的文档可以有相同的唯一的标识符。</p>
<p>9.一个索引对象可以存储很多不同用途的对象。如，一个博客程序可以保存文章和评论。文档类型让我们轻易地区分单个索引中的不同对象，每个文档可以有不同的结构，但是实际操作中，将文件按类型区分对数据操作有很大帮助。<strong>在一个索引中，即使文档类型不同，相同的属性不能设置不同的类型</strong></p>
<p>文档类型对应索引中不同的对象。</p>
<p>10.映射:文档中的每个字段都必须根据不同类型做相应的分析。Elasticsearch中映射中存储有关字段的信息。每一个文档类型都有自已的映射，即使我们没有明确定义。</p>
<p>11.几个概念：集群、节点、分片（索引较大时，可以分成较小的片，每个片可以放到不同的服务器上，Elasticrearch可以自动把查询分给不同的片并合并结果，应用程序并不知道片的存在。）、副本（每个片可以有0到多个副本，其中一片会被自动选择去更改索引操作，这种特别的分片叫主分片，其作的片就是完整的备份，叫副本分片。主分片丢失时，会有新的副本分片被推荐成新的主分片）</p>
<p>12.当发送一个新的文档集群时，你指定一个目标索引并发送给他的任意一个节点。这个节点知道目标索引有多个分片，并能确定那个分片应该存储你的文档。ElasticSearch使用文档的唯一标识符来计算文档应该被存放在那个分片中。索引请求发送一个节点后，该节点会转发文档到持有相关分片的目标节点中。</p>
<p>建立索引时，副本只作为额外的存储备份来用。查询时，副本会平衡分片和它的副本之前的负载。</p>
<p>13.与Elasticsearch交互的主要接口是基于HTTP协议和REST的。可以使用浏览器来请求，复杂的可以使用<a href="http://curl.haxx.se/download.html" target="_blank" rel="external">curl</a>来请求。</p>
<p>14.安装：rpm安装包安装好后，配置文件应该在/etc/sysconfig/elasticsearch。如果操作系统基于红帽，可以使用/etc/init.d/elasticsearch下的init脚本。如果你的操作系统是SUSE Linux，可以使用/bin下的systemctl文件来启动和停止Elasticsearch服务。<br>        deb安装包安装后，配置文件存在/etc/elasticsearch/elasticsearch.yml。/etc/init.d/elasticsearch下的init脚本可以用来启动和停止Elasticsearch。此外，/etc/default/elasticsearch下的文件包含了环境变量。</p>
<p>15.目录结构：</p>
<ul>
<li>bin：运行Elasticsearch实例和插件管理所需的脚本</li>
<li>config：配置文件所在的目录</li>
<li>lib：Elasticsarch使用的库</li>
</ul>
<p>运行后，会创建以下目录：</p>
<ul>
<li>data：Elasticsearch使用的所有数据的存储位置</li>
<li>logs：关于事件和错误记录的文件</li>
<li>plugins：存储所安装插件的地方</li>
<li>work：Elasticsearch使用的临时文件</li>
</ul>
<p>16.Elasticsearch的配置下有两个文件elasticsearch.yml(或elasticsearch.json，如果有的话会被用)和logging.yml。第一个文件负责设置服务器的默认配置值，因为一些配置值可以在运行时更改，所以这个文件中的值可能不准确。有两个值不能在运行是更改，分别是<code>cluster.name</code>和<code>node.name</code>。</p>
<p><code>cluster.name</code>用来定义集群的名字，不同的集群用名字来区分，配置成相同集群名字的各个节点形成一个集群。</p>
<p><code>node.name</code>是实例的名字，可以不定义此参数，此时会自动生成一个。所以为了自已使用，还是最好自已定义一下。</p>
<p><code>logging.yml</code>定义了多少信息写入系统日志，定义了日志文件，并定期创建新文件。只有在调整监控、备份方案或系统调试时，才需要修改。</p>
<p>在建立索引时，尤其是很多分片和副本的情况下，Elasticsearch将创建很多文件，所以系统不能限制打开的文件小于32000个。在linux上，一般在/etc/security/limits.conf中修改，当前的值可以用ulimit命令来查看。如果达到极限，Elasticsearch将无法创建文件，所以合并会失败，索引会失败，新的索引会失败。</p>
<p>如果在日志文件中发现OutOfMemoryError异常的条目，把ES_HEAP_SIZE变量设置到大于1024.当选择分配给JVM合适内存大小时，记住，通常不应该分配超过50%的系统总内存。</p>
<p>17.启动Elasticsearch后，一般使用2个端口号：第1个是使用HTTP协议与REST API通信的端口，第2个是传输模块，是用来在集群内以及Java客户端和集群之前通信的端口，前者是9200，后者是9300。<strong>在一个Elasticsearch上启动两次后，会启动两个实例，而且他们检测到端口冲突后，会自动选择新的端口。</strong></p>
<p>18.关闭集群有三种方法：</p>
<ul>
<li>在控制台，直接Ctrl+C</li>
<li>通过kill命令来杀死</li>
<li>使用REST API</li>
</ul>
<p>19.Elasticsearch作为系统服务。如果是在linux上安装的，则已经自动完成了。如果是解压的，则按以下步骤进行：</p>
<pre><code><span class="number">1.</span> curl -L <span class="string">http:</span><span class="comment">//github.com/elasticsearch/elasticsearch-servicewrapper/tarball/master | tar -xz</span>
<span class="number">2.</span> sudo mv *servicewrapper* <span class="regexp">/service/</span>usr<span class="regexp">/local/</span>share<span class="regexp">/elasticsearch/</span>bin<span class="regexp">/          /</span>/将下载的服务封装软件移到elasticsearch的bin目录下
<span class="number">3.</span> rm -Rf *servicewrapper*    <span class="comment">//移除原有的下载目录</span>
<span class="number">4.</span> sudo <span class="regexp">/usr/</span>local<span class="regexp">/share/</span>elasticsearch<span class="regexp">/bin/</span>service<span class="regexp">/elasticsearch install    /</span>/通过install命令来安装服务
<span class="number">5.</span> sudo ln -s ‘readlink -f <span class="regexp">/usr/</span>local<span class="regexp">/share/</span>elasticsearch<span class="regexp">/bin/</span>service<span class="regexp">/elasticsearch’ /</span>usr<span class="regexp">/local/</span>bin<span class="regexp">/rcelasticsearch    /</span>/创建符号链接指向该脚本
<span class="number">6.</span> <span class="regexp">/etc/</span>init.d<span class="regexp">/elasticsearch start    /</span>/启动Elasticsearch
</code></pre><p>如果是在windows上安装的，则执行：</p>
<pre><code><span class="number">1</span>. service<span class="class">.bat</span> install
<span class="number">2</span>. service<span class="class">.bat</span> start
</code></pre><p>在命令行直接输入service.bat还可以查看其它的命令</p>
<p>20.<code>GET</code>用来获得请求对象的当前状态，<code>POST</code>用来改变对象的当前状态<code>，</code>PUT<code>创建一个对象，</code>DELETE<code>销毁对象，</code>head`请求获取对象的基本信息。</p>
<p>21.默认情况下,Elasticsearch在添加、更改或删除文档时会递增版本号。当然，它也可以使用我们提供给它的版本号。在版本存储在外部系统时，这是必要的。为了告诉elasticsearch我们使用的是外部版本号，需设置：<code>version_type=external</code>参数。</p>
<p>22.默认情况下，删除的文档在60S内仍然可以查询版本信息，可以通过index.gc_deletes配置参数来更改这个值。</p>
<p>23.为了搜索一个给定的类型，需要指定一个或多个类型。需要查找任意索引，直接*即可，或忽略索引名称。</p>
<h2 id="第1章_入门－命令">第1章 入门－命令</h2><ul>
<li>查看搜索是否就绪：<code>http://127.0.0.1:9200</code></li>
<li>检查集群健康度：<code>curl -XGET http://127.0.0.1:9200/_cluster/health?pretty</code>,-X是一个参数方法，默认是<code>GET</code>（可忽略），<code>pretty</code>是使返回json串格式化，否则会返回一串。</li>
<li>关闭整个集群：<code>curl -XPOST http://127.0.0.1:9200/_cluster/nodes/_shutdown</code></li>
<li>关闭集群某个节点：<code>curl -XPOST http://127.0.0.1:9200/_cluster/nodes/abcdefg/_shutdown</code>,<code>abcdefg</code>为某一节点的标识符。</li>
<li>查看节点的标识符：<code>curl -XGET http://127.0.0.1:9200/_cluster/nodes/</code></li>
<li>查看集群中节点信息：<code>curl  -XGET http://127.0.0.1:9200/_cluster/state/nodes/</code></li>
<li>存一条数据:<code>curl -XPUT http://127.0.0.1:9200/blog/article/1 -d &#39;{&quot;id&quot;:&quot;1&quot;,&quot;title&quot;:&quot;Elasticsearch的新版本发布了！&quot;,&quot;content&quot;:&quot;今天1.0版本发布&quot;,&quot;priority&quot;:10,&quot;tags&quot;:[&quot;发布&quot;,&quot;elasticsearch&quot;,&quot;发布&quot;]}&#39;</code>,如果索引等不存在,会自动创建,这句话创建了一个名为blog的索引,创建了一个名为article的类型,这下面的对象的标识符设置为1,存了进去。-d表示后边是请求的主体。把PUT改为POST，后边的1就可以省略了，会自动生成标识符，这相当于修改了索引。另外，如果后边使用了数据库，标识符则不会自动生成，除非数据库中也存储生成标识符。</li>
<li>取出刚才存的文档：<code>curl -XGET http://127.0.0.1:9200/blog/article/1</code></li>
<li><p>更新文档内容:<code>curl -XPOST http://127.0.0.1:9200/blog/article/1/_update -d &#39;{&quot;script&quot;:&quot;ctx._source.content=\&quot;新内容\&quot;&quot;}&#39;</code>,此参数需要配置elasticsearch.yml中的配置文件,才可以使用。而且不同的版本配置参数名不同，我是1.7.1版本，所以配置的参数为：</p>
<pre><code><span class="keyword">script</span>.inline: <span class="function_start"><span class="keyword">on</span></span>
<span class="keyword">script</span>.indexed: <span class="function_start"><span class="keyword">on</span></span>
</code></pre></li>
</ul>
<p>具体版本的配置方式参见：(<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html" target="_blank" rel="external">https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html</a>)</p>
<ul>
<li>为已经实体增加一个新字段<code>curl -XPOST http://127.0.0.1:9200/blog/article/1/_update -d &#39;{&quot;script&quot;:&quot; ctx._source.counter = 1 &quot; }&#39;</code> ,下面是一个更复杂的例子:<code>curl -XPOST http://127.0.0.1:9200/blog/article/1/_update -d &#39;{&quot;script&quot;:&quot;if (!ctx._source.counter) {ctx._source.counter = 1};ctx._source.counter  += count&quot;,  &quot;params&quot;: {    &quot;count&quot;: 1  }}&#39;</code></li>
<li>删除刚才存的文档：<code>curl -XDELETE http://127.0.0.1:9200/blog/article/1</code></li>
<li>使用外部版本号时,需指定,如:<code>curl -XPUT &#39;localhost:9200/library/book/1?version=123456&#39; -d {...}</code>,在做一些更新操作时,需保证版本号比现有的大,否则会操作失败。</li>
<li>安装插件：<code>elasticsearch/bin plugin -install mobz/elasticsearch-head</code></li>
<li>访问已安装插件:<code>http://127.0.0.1:9200/_plugin/head/</code></li>
</ul>
<p><strong>一个例子</strong></p>
<p>1.输入数据：</p>
<pre><code><span class="keyword">curl</span> -XPUT http://127.0.0.1:9200/books/es/1 -d '{<span class="string">"title"</span>:<span class="string">"Elasticsearch Server"</span>,<span class="string">"published"</span>:2013}'
<span class="keyword">curl</span> -XPUT http://127.0.0.1:9200/books/es/2 -d '{<span class="string">"title"</span>:<span class="string">"Mastering Elasticsearch"</span>,<span class="string">"published"</span>:2013}'
<span class="keyword">curl</span> -XPUT http://127.0.0.1:9200/books/es/3 -d '{<span class="string">"title"</span>:<span class="string">"Apache Solr 4 cookbook"</span>,<span class="string">"published"</span>:2012}'
</code></pre><p>2.查询：</p>
<ul>
<li>在某一索引内查找：<code>curl -XGET &#39;http://127.0.0.1:9200/books/_search?pretty&#39;</code></li>
<li>在某两个索引内查找：<code>curl -XGET &#39;http://127.0.0.1:9200/books,clients/_search?pretty&#39;</code></li>
<li>在某索引内某个类型下查找：<code>curl -XGET &#39;http://127.0.0.1:9200/books/es/_search?pretty&#39;</code></li>
<li>在全部里面搜索：<code>curl -XGET &#39;http://127.0.0.1:9200/_search?pretty&#39;</code></li>
<li><p>在books索引中title字段包含elasticsearch一词的所有文档：<code>curl -XGET &#39;http://127.0.0.1:9200/books/_search?pretty&amp;q=title:elasticsearch&#39;</code></p>
<pre><code>{
  <span class="string">"took"</span> : <span class="number">6</span>,<span class="comment">//花费时间,单位是毫秒</span>
  <span class="string">"timed_out"</span> : <span class="literal">false</span>,<span class="comment">//有没有超时</span>
  <span class="string">"_shards"</span> : {<span class="comment">//分片信息</span>
    <span class="string">"total"</span> : <span class="number">5</span>,
    <span class="string">"successful"</span> : <span class="number">5</span>,<span class="comment">//成功返回结果的分片数量</span>
    <span class="string">"failed"</span> : <span class="number">0</span>
  },
  <span class="string">"hits"</span> : {
    <span class="string">"total"</span> : <span class="number">2</span>,<span class="comment">//查询结果总数</span>
    <span class="string">"max_score"</span> : <span class="number">0.19178301</span>, <span class="comment">//计算最高得分</span>
    <span class="string">"hits"</span> : [ {<span class="comment">//请求返回结果</span>
      <span class="string">"_index"</span> : <span class="string">"books"</span>,
      <span class="string">"_type"</span> : <span class="string">"es"</span>,
      <span class="string">"_id"</span> : <span class="string">"1"</span>,
      <span class="string">"_score"</span> : <span class="number">0.19178301</span>,
      <span class="string">"_source"</span>:{<span class="string">"title"</span>:<span class="string">"Elasticsearch Server"</span>,<span class="string">"published"</span>:<span class="number">2013</span>}
    }, {
      <span class="string">"_index"</span> : <span class="string">"books"</span>,
      <span class="string">"_type"</span> : <span class="string">"es"</span>,
      <span class="string">"_id"</span> : <span class="string">"2"</span>,
      <span class="string">"_score"</span> : <span class="number">0.19178301</span>,
      <span class="string">"_source"</span>:{<span class="string">"title"</span>:<span class="string">"Mastering Elasticsearch"</span>,<span class="string">"published"</span>:<span class="number">2013</span>}
    } ]
  }
}
</code></pre></li>
</ul>
<ul>
<li><p>查看某一词建立的索引具体是什么:<code>curl -XGET &#39;http://127.0.0.1:9200/books/_analyze?field=title&#39; -d &#39;Elasticsearch Server&#39;</code>，可以看到，分成了两个词。</p>
</li>
<li><p>URI查询行为：<code>curl -XGET &#39;http://127.0.0.1:9200/books/_search?pretty&amp;q=published:2013&amp;df=title&amp;explain=true&amp;default_operator=AND&#39;</code>。</p>
<ul>
<li>参数q用来指定我们希望查询的条件</li>
<li>df可以指定在q参数中没有字段时应该默认命名用的字段。默认使用使用_all字段。</li>
<li>analyzer属性定义用于分析查询的分析器名称。默认情况下，索引阶段对字段内容做分析的分析器将用来分析我们的查询</li>
<li>default_operator属性可以设置成OR或AND，用来指定用于查询的默认布尔运算符，指定查询条件间的关系。</li>
<li>explain参数设置为true，将返回更加详细的信息，如文档从那个分片上获取的，得分多少。一般不使用这个参数，很影响性能。</li>
<li>默认返回的文档中包括索引名称、类型名称、文档标识符、得分和_source字段。如想返回其它字段，可以用fields参数，并指定一个以逗号分隔的字段名称列表。这些字段将在内部存储字段或内部_source字段中检索。默认情况下，字段fields参数值是_source。也可以通过_source=false来禁用在_source中读取。</li>
<li>结果排序：默认是根据得分排序。可以指定：sort=published:desc；sort=published:asc。如果自定义排序，则不会计算得分。可以通过设定track_scores=true来要求计算。</li>
<li>默认情况没有超时发生，可以设定一个超时时间，timeout＝5，单位是秒。</li>
<li>返回指定结果：size:默认是10，它定义了返回文档的最大数量，默认是10；from定义了结果应该从那个记录开始返回，默认为0。如从第11个开始返回5个文档：size=5&amp;from=10</li>
<li>URI查询允许使用search_type参数指定搜索类型，搜索类型默认为query_then_fetch。它共有dfs_query_then_fetch、dfs_query_and_fetch、query_then_fetch、query_and_fetch、count、scan。</li>
<li>一些查询使用查询扩展如前辍查询(prefix query)。可以用lowercase_expanded_terms属性来定义扩展词是否应该被转化为小写。默认为true。</li>
<li>默认情况下，通配符查询和前辍查询不会被分析。如果要分析，可以把analyze_ildcard属性设置为true。</li>
<li>查询被lucene的查询解析器分为词term和操作符operator。title：book，title:”elasticsearch book”。操作符+表示必须匹配，操作符-表示不包含，没有+-的表示，可以匹配，但非强制性查询。如想找title包含book但description字段不包含cat一词的文档：+title:book -description:cat；也可以用括号来组合多个词title:{crime punishment}。还可以使用^来标识加强该词的相关性：title:book^4。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2009-03-19T01:12:53.000Z"><a href="/2009/03/19/eclipse插件开发获取路径的几种方式/">2009-03-19</a></time>
      
      
  
    <h1 class="title"><a href="/2009/03/19/eclipse插件开发获取路径的几种方式/">eclipse插件开发获取路径的几种方式</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1.得到runtime workspace目录的绝对路径</p>
<pre><code><span class="type">String</span> file = <span class="type">Platform</span>.getInstanceLocation<span class="literal">()</span>.getURL<span class="literal">()</span>.getPath<span class="literal">()</span>;
</code></pre><p>2.得到runtime workspace目录下所有的工程</p>
<pre><code>IWorkspace workspace = ResourcesPlugin.getWorkspace<span class="params">()</span>;
   IWorkspaceRoot root = workspace.getRoot<span class="params">()</span>;
   IProject[] newProjectHandle = root.getProjects<span class="params">()</span>;

<span class="keyword">for</span> <span class="params">(int i = <span class="number">0</span>, size = newProjectHandle.length; i &lt; size; i++)</span> {
    IProject iProject = newProjectHandle[i];

    <span class="comment">// 工程名字</span>
String projectName = iProject.getName<span class="params">()</span>;
IResource[] resources = iProject.members<span class="params">()</span>;
    <span class="keyword">for</span> <span class="params">(int j = <span class="number">0</span>, n = resources.length; j &lt; n; j++)</span> {
     <span class="keyword">if</span> <span class="params">(resources[j].getType<span class="params">()</span> == IResource.FILE
       &amp;&amp; resources[j].getFileExtension<span class="params">()</span>.equals<span class="params">(<span class="string">"xpdl"</span>)</span>)</span> {
      <span class="comment">// 包:工程下xpdl文件的绝对路径,包路径</span>
      String xpdlFileFullPath = resources[j].getLocation<span class="params">()</span>
        .toOSString<span class="params">()</span>;
      }
     }
}
</code></pre><p>3.取插件项目所在路径</p>
<pre><code>public static String getPluginPath<span class="params">()</span>{
  String pluginPath=null;
  try {
   pluginPath = FileLocator.toFileURL<span class="params">(
           Platform.getBundle<span class="params">(Activator.PLUGIN_ID)</span>.getEntry<span class="params">(<span class="string">""</span>)</span>)</span>.getPath<span class="params">()</span>;
   pluginPath = pluginPath.substring<span class="params">(<span class="number">1</span>)</span>;
  } catch <span class="params">(IOException e1)</span> {
   <span class="comment">// TODO 自动生成 catch 块</span>
   e1.printStackTrace<span class="params">()</span>;
  }
  return pluginPath;  
} 
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/eclipse插件开发/">eclipse插件开发</a><small>1</small></li>
  
    <li><a href="/tags/elasticsearch/">elasticsearch</a><small>3</small></li>
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2015 okuc
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>