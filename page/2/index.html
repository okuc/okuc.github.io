<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | 我的后院自留地</title>
  <meta name="author" content="okuc">
  
  <meta name="description" content="hadoop hive hbase cassandra linux elasticsearch eclipse java mysql spark titan tinkpop neo4j">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="我的后院自留地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="我的后院自留地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7ea69d6de48b6d7cd2a53bcc519beadc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">我的后院自留地</a></h1>
  <h2><a href="/">琴棋书画诗酒花 当年件件不离它 而今事事都变更 柴米油盐酱醋茶</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="//">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/coding">编程技术</a></li>
    
      <li><a href="/bigData">大数据技术</a></li>
    
      <li><a href="/dataV">数据可视化</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-24T14:59:45.000Z"><a href="/2016/06/24/JAVA8学习（九）/">2016-06-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/24/JAVA8学习（九）/">JAVA8学习（九）</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><strong>try-with-resources</strong> Java7提供了一个简单实用的代码格式，如下：<br>打开一个资源<pre><code>try{
    使用该资源
}finally{
    关闭该资源
}
</code></pre>其中资源所属的类必须实现了AutoCloseable接口。该接口只有一个方法：<code>void close() throws Exception</code><pre><code>try-with-resources语句的最简单形式如下所示：
try(Resource res = ...){
   使用res
}
</code></pre>当<code>try</code>语句块退出时，会自动调用<code>res.close()</code>方法。下面是一个经典示例—-读取一个文件中的所有单词：<pre><code>try(Scanner in = new Scanner(Paths.get(&quot;/usr/share/dict/words&quot;))){
   while(in.hasNext()) System.out.println(in.next().toLowerCase());
}
</code></pre>当代码块像往常一样退出或者发生异常时，都会调用<code>in.close()</code>方法，就如同之前<code>finally</code>一样<br>在Java7中，可以在同一个<code>catch</code>分支中捕获多个异常类型，如<code>catch(FileNotFoundException|UnknownHostException ex)</code>。<br>对于反射方法的异常，Java7单独引进了一个新的父类：<code>ReflectiveOperationException</code>。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/24/JAVA8学习（九）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-23T14:59:45.000Z"><a href="/2016/06/23/JAVA程序员学习Scala（二）/">2016-06-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/23/JAVA程序员学习Scala（二）/">JAVA程序员学习Scala（二）</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><code>Scala</code>的<code>actor</code>提供了一种基于事件的轻量级线程。只要使用<code>scala.actors.Actor</code>伴生对象的<code>actor()</code>方法，就可以创建一个<code>actor</code>。它接受一个函数值/闭包做参数，一创建好就开始运行。用!()方法给<code>actor</code>发消息，用<code>receive()</code>方法从<code>actor</code>接收消息。<code>receive()</code>也可以闭包为参数，通常用模式匹配处理接收到的消息。</li>
<li>如果想要遍历容器里的元素，执行一些操作，<code>Scala</code>程序库已经内建了这个方法，<code>foldLeft()</code>,也就是<code>/:</code>方法：<pre><code>val sum = (0 /: (1 to number)){(sum,i)=&gt;sum+i}
</code></pre></li>
<li>如果<code>scala</code>类及其引用的类在不同的目录，比如在<code>entities</code>目录中，可以在<code>scala</code>的<code>sourcepath</code>选项里面指定这个目录：<code>scala -sourcepath entities:. userPerson.scala</code>。<code>userPerson.scala</code>用到了<code>entities</code>中的<code>Person.scala</code>类。如果类是以编译过的形式存在不同的目录下，就要使用<code>classpath</code>选项。<code>scalac -d . -classpath LocationOfPersonClassFile UsePersonClass.scala</code>//-d用来说明字节码存放地点。</li>
<li>如果想在<code>java</code>中运行，只要在<code>classpath</code>里指定<code>scala-library.jar</code>文件。<pre><code>scalac -sourcepath . UsePersonClass.scala
java -classpath /opt/scala/scala-2.7.4.final/lib/scala-library.jar:. UsePerson
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/23/JAVA程序员学习Scala（二）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-22T14:59:45.000Z"><a href="/2016/06/22/外网访问内网kafka访问不到问题的解决/">2016-06-22</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/22/外网访问内网kafka访问不到问题的解决/">外网访问内网kafka访问不到问题的解决</a></h1>
  

    </header>
    <div class="entry">
      
        <p>由于需要在外网访问内网kafka，所以在公司的网络出口处做了端口映射，对kafka所需要9092，zookeeper所需的2181端口都做了映射。但是仍然无法访问，报了以下错误：</p>
<pre><code>2016-06-22 05:49:18.237-[ProducerSendThread-]- WARN {kafka.utils.Logging$class:89}-Failed to send producer request with correlation id 4073 to broker 0 with data for partitions [TOPIC_,0],[TOPIC_My,0]
java.nio.channels.ClosedChannelException
        at kafka.network.BlockingChannel.send(BlockingChannel.scala:100)
        at kafka.producer.SyncProducer.liftedTree1$1(SyncProducer.scala:73)
        at kafka.producer.SyncProducer.kafka$producer$SyncProducer$$doSend(SyncProducer.scala:72)
        at kafka.producer.SyncProducer$$anonfun$send$1$$anonfun$apply$mcV$sp$1.apply$mcV$sp(SyncProducer.scala:103)
        at kafka.producer.SyncProducer$$anonfun$send$1$$anonfun$apply$mcV$sp$1.apply(SyncProducer.scala:103)
        at kafka.producer.SyncProducer$$anonfun$send$1$$anonfun$apply$mcV$sp$1.apply(SyncProducer.scala:103)
        at kafka.metrics.KafkaTimer.time(KafkaTimer.scala:33)
        at kafka.producer.SyncProducer$$anonfun$send$1.apply$mcV$sp(SyncProducer.scala:102)
        at kafka.producer.SyncProducer$$anonfun$send$1.apply(SyncProducer.scala:102)
        at kafka.producer.SyncProducer$$anonfun$send$1.apply(SyncProducer.scala:102)
        at kafka.metrics.KafkaTimer.time(KafkaTimer.scala:33)
</code></pre><p> 或者如下错误：</p>
<pre><code>Exception in thread &quot;main&quot; kafka.common.FailedToSendMessageException: Failed to send messages after 3 tries.
    at kafka.producer.async.DefaultEventHandler.handle(DefaultEventHandler.scala:90)
    at kafka.producer.Producer.send(Producer.scala:77)
    at kafka.javaapi.producer.Producer.send(Producer.scala:33)
</code></pre><p> 但是，如果我在内网环境中，通过外网ip访问，则没有问题。经过排查，最终解决了该问题，原因如下：<strong>在设置config/server.properties配置文件时，将host.name参数设置为了该机器的ip，导到与客户端交互时，将该内网ip带到了外网，从而出现的问题。</strong><br> 解决方案如下：<br> <strong>将config/server.properties配置文件中的host.name参数设置为该机器的机器名，同时，在客户端机器上设置hosts文件，将该机器名对应的ip设为外网映射端口的ip，即可。或者不设该参数，统一使用机器名来访问（外网需设hosts文件）</strong></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-20T14:59:45.000Z"><a href="/2016/06/20/JAVA8学习（八）/">2016-06-20</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/20/JAVA8学习（八）/">JAVA8学习（八）</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><strong>字符串连接</strong>：<pre><code>String joined = String.join(&quot;/&quot;,&quot;usr&quot;,&quot;local&quot;,&quot;bin&quot;);//&quot;usr/local/bin&quot;;
System.out.println(joined);
String ids = String.join(&quot;,&quot;,ZoneId.getAvailableZoneIds());
System.out.println(ids);//将所有的时区标识，由逗号分隔
</code></pre></li>
<li><code>java5</code>中，7种原始类型的包装类（不包含Boolean）都提供了一个静态字段<code>SIZE</code>，用来表示该类型以<code>bit</code>为单位的长度。在<code>Java8</code>中，它们都提供了一个<code>BYTES</code>字段，以<code>byte</code>为单位来表过该类型的长度，以便于用于无法被8整除的情况。</li>
<li>为了在流操作中进行聚合操作，<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>和<code>Double</code>这5种类型，现在分别提供了静态方法<code>sum</code>、<code>max</code>、<code>min</code>，用来在流操作中作为聚合函数使用。出于相同的原因，<code>Boolean</code>类现在也包含了静态方法<code>logicalAnd</code>、<code>logicalOr</code>、<code>logicalXor</code>。</li>
<li><code>Integer</code>类现在支持无符号数学计算。静态方法<code>Byte.toUnsignedInt(b)</code>来获取一个从<code>0</code>到<code>255</code>的值。一般使用无符号数字，会丢失负数并获得原来两范围的正数。<code>Byte</code>和<code>Short</code>类中添增了<code>toUnsignedInt</code>方法，而<code>Byte</code>、<code>Short</code>、<code>Integer</code>类中新增了<code>toUnsignedLong</code>方法。</li>
<li><code>Integer</code>和<code>Long</code>类中新增了处理无符号值的<code>compareUnsigned</code>、<code>divideUnsigned</code>和<code>remainderUnsigned</code>方法。由于大于<code>Integer.MAX_VALUE</code>的无符号整数相乘会导致溢出，所以应该调<code>toUnsignedLong</code>将它们作为长整型值相乘。</li>
<li><code>Float</code>和<code>Double</code>类现在新增了静态方法<code>isFinite</code>,如果<code>x</code>不是正无穷大、负无穷大或者<code>NaN</code>(非数字)，那么<code>Double.isFinite(x)</code>将返回<code>true</code>。</li>
<li><code>BigInteger</code>类增加了实例方法<code>（long|int|short|byte）ValueExact</code>，分别用来返回<code>long</code>、<code>int</code>、<code>short</code>或者<code>byte</code>，并且当值不在目标范围内时抛出一个<code>ArithmeticExcepiont</code>异常。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/20/JAVA8学习（八）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-10T14:59:45.000Z"><a href="/2016/06/10/JAVA8学习（七）/">2016-06-10</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/10/JAVA8学习（七）/">JAVA8学习（七）</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><code>java8</code>提供了一个命令行工具<code>jjs</code>。你只需要启动它，并执行<code>JavaScript</code>命令即可启动：<pre><code>jjs
jjs&gt;&apos;Hello,World&apos;
Hello,World
jjs&gt;&apos;Hello,World.length
5
</code></pre></li>
<li>在<code>js</code>中定义字符串可以是单引号也可以是双引号。每行后边可以加分号也可以不加。</li>
<li>在<code>jjs</code>中定义函数并调用它们<pre><code>jjs&gt;function factorial(n){return n&lt;=1?1:n*factorial(n-1)}
function factorial(n){return n&lt;=1?1:n*factorial(n-1)}
jjs&gt;factorial(10)
3628800
</code></pre>-<code>jjs</code>中调用<code>java</code>的方法<pre><code>var input = new java.util.Scanner(new java.net.URL(&apos;http://horstmann.com&apos;).openStream())
input.useDelimiter(&apos;$&apos;)
var contents = input.next()
contents
</code></pre></li>
<li><code>jjs</code>又被称为<code>REPL</code>，可以用这种方式来学习<code>java API</code>，但是它没有<code>Scala</code>做得那么好。因为它的自动提示不友好，不能提示。可以尝试安装<code>rlwrap jjs</code>或在<code>Emacs</code>中运行<code>jjs</code>来解决这一问题。</li>
<li>在<code>Java</code>中，可以使用<code>Java6</code>中引入的脚本引擎机制来运行一个<code>Nashorn</code>脚本。通过脚本引擎，可以执行任何JVM语言的脚本，如<code>Groovy</code>、<code>JRuby</code>、<code>Jython</code>。此外，还有另外一些脚本引擎用于支持任何<code>JVM</code>以外的语言，如<code>PHP</code>、<code>Scheme</code>。</li>
<li><code>java8</code>中运行<code>nashorn</code>的示例如下：<pre><code>ScriptEngineManager manager = new ScriptEngineManager();//获取注册的引擎管理器
ScriptEngin engin = manager.getEngineByName(&quot;nashorn&quot;);//通过名称获取指定引擎
Object result = engine.vale(&quot;&apos;Hello,world!&apos;.length&quot;);
System.out.println(result);
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/10/JAVA8学习（七）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-09T14:59:45.000Z"><a href="/2016/06/09/JAVA8学习（六）/">2016-06-09</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/09/JAVA8学习（六）/">JAVA8学习（六）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ul>
<li><code>java5</code>提供了强大的<code>java.util.concurrent</code>包，该包为我们提供了线程安全的集合和线程池，使得许多应用开发人员不必使用锁或者启动新线程，就可以编写并发程序。</li>
<li><code>java5</code>开始<code>java.util.concurrent.atomic</code>包提供了用于支持无锁可变变量的类，保证多线程并发访问同一个实例，也能正确计算并返回正确的值。如：<pre><code>public static AtomicLong nextNumber = new AtomicLong();
//在某些线程中
long id= nexNumber.incrementAndGet();//会自动将AtomicLong的值加1，并返回增加后的值。
</code></pre></li>
<li><p><code>java5</code>中提供了很多设置、增加、减少值的原子操作，但是如果想要进行更复杂的更新操作，必须使用<code>compareAndSet</code>方法。如想追踪由不同线程所监测的最大值，则下面的代码是行不通的：</p>
<pre><code>public static AtomicLong nextNumber = new AtomicLong();
//在某些线程中
largest.set(Math.max(largest.get(),observed)) //错误，竟争条件，非原子性操作。

do{
    oldValue = largest.get();
    newValue = Math.max(oldValue,observed);
}while(!largest.compareAndSet(oldValue,newValue));//正确方式，每个线程每次都取新旧值判断，只有符合要求时才会赋值。如果是java8,可以如下写：
largest.updateAndGet(x-&gt;Math.max(x,observed));
largest.accumulateAndGet(observed,Math::max);//accumulateAndGet方法通过一个二元运算符将原子值和传入的参数组合起来。
</code></pre><p>除了它之外，Java8还提供了返回原始值的<code>getAndUpdate</code>方法和<code>getAndaccumulateAndGet</code>方法。</p>
</li>
<li><code>AtomicInteger</code>、<code>AtomicIntegerArray</code>、<code>AtomicIntegerFieldupdater</code>、<code>AtomicLongArray</code>、<code>AtomicLongFieldUpdater</code>、<code>AtomicRefernce</code>、<code>AtomicReferenceArray</code>和<code>AtomicReferenceFieldUpdater</code>类都提供了这些方法。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/09/JAVA8学习（六）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-08T14:59:45.000Z"><a href="/2016/06/08/JAVA8学习（五）/">2016-06-08</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/08/JAVA8学习（五）/">JAVA8学习（五）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h2><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><ul>
<li><code>Java</code>日期和时间<code>API</code>规范要求<code>Java</code>使用如下年1月1日， 时标：<ul>
<li>每天都有<code>86400</code>秒</li>
<li>每天正午与官方时间准确匹配</li>
<li>其他时间也要以一种精确定义的方式与其紧密匹配</li>
</ul>
</li>
<li><code>Java</code>中，一个<code>Instant</code>对象表示时间轴上的一个点。原点（元年）为<code>1970</code>,<code>UNIX/POSIX</code>时间也使用了一样的约定。从86400秒进行计算，向前向后分别以纳秒为单位。</li>
<li><code>Instant</code>的最大值（<code>Instant.MAX</code>）表示<code>1000000000年的12月31日</code>。静态方法<code>Instant.now()</code>会近回当前的瞬时点。可以使用<code>equals</code>和<code>compareTo</code>方法来比较两个瞬时点，以便将它们作为时间戳使用。</li>
<li>要计算两个瞬时点之间的时间距离，你可以使用静态方法Duration.between.<pre><code>Instant start = Instant.now();
runAlgorithm();
Instant end = Instant.now();
Duration timeElapsed = Duration.between(start,end);
long millis = timeElapsed.toMillis();
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/08/JAVA8学习（五）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-04T14:59:45.000Z"><a href="/2016/06/04/JAVA程序员学习Scala（一）/">2016-06-04</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/04/JAVA程序员学习Scala（一）/">JAVA程序员学习Scala（一）</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><code>Scala</code>环境设置，将<code>bin</code>目录加到<code>path</code>中即可。</li>
<li>命令行中，输入<code>scala</code>进入<code>Shell</code>环境，<code>Ctrl+A</code>回到行首，<code>Ctrl+E</code>到达行尾，如果没敲完，就回车，会出现<code>|</code>，提示你继续输入。<code>:quit</code>或者<code>exit</code>退出<code>shell</code>。</li>
<li>也可以在命令行中，直接输入<code>scala -e &quot;println(\&quot;Hello \&quot;+args(0)+\&quot;,\&quot;+args(1))&quot; Buddy &quot;welcome to Scals</code>,<strong>没测试通过</strong></li>
<li>还可以使用<code>:load</code>选项把它载入<code>shell</code>。<code>:load script.scala</code>。<code>scala Helloworld.scala</code>。<code>scala后</code>边的参数可以是脚本，也可以是目标文件(<code>.class</code>文件)。在给它传递<code>Java</code>属性的时候，可以用<code>-Dproperty=value</code>格式。在文件前边加上<code>-avaecompiled</code>选项，<code>Scala</code>工具会把字节码存成一个<code>Jar</code>文件。</li>
<li><p>在类<code>Unix</code>的<code>shell</code>上，可以写脚本：</p>
<pre><code>#!/usr/bin/env scala
!#
println(&quot;hello &quot;+args(0))
 然后添加执行权限：chmod +x Script.scala即可直接执行。./Sript.scala okuc。okuc是参数。
- 在windows上，可以在bat批处理中带参数的方式，如下：
echo off
cls
call scala %1
pause
</code></pre></li>
<li><p>一个简单的例子：</p>
<pre><code>for(i&lt;-1 to 3){//包括3
  print(i+&quot;,&quot;)
}
println(&quot;Scala Rocks!!!&quot;)

for(i&lt;-1 until 3){//不包括3
  print(i+&quot;,&quot;)
}
println(&quot;Scala Rocks!!!&quot;)
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/04/JAVA程序员学习Scala（一）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-04T14:59:45.000Z"><a href="/2016/06/04/JAVA8学习（四）/">2016-06-04</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/04/JAVA8学习（四）/">JAVA8学习（四）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h2><ul>
<li>在javaFx中，你可以在一个场景上放置任何你想要展现的东西。因此，你可以设计“演员”—即控件的形状的样式和行为。</li>
<li>场景需要舞台，如果运行在桌面系统上，舞台就是一个顶经的窗口，如果作为一个applet运行，舞台就是一个长方形的区域。</li>
<li>在任何Application类的子类中，我们都必须重写start方法，然后将场景作为一个参数传递给start方法。</li>
</ul>
<p>Button red = new Button(“red”);<br>red.setOnAction(event-&gt;message.setTextFile(Color.REd));</p>
<ul>
<li><p>对于大多数JavaFX控件来说，它们的事件处理方式是不同的，以一个滑块为例，当滑块被调整时，它的值就会发生改变。但是，不应该监听滑块发出的表示这些改变的底层事件，相反，滑块有个个JavaFX属性value，该属性会在发生改变时发起事件。<br><code>slider.valueProperty().addListener(property-&gt;message.setFont(new Font(slider.getValue())))</code><br>-<code>java.beans</code>包中的<code>Introspector</code>和<code>BeanInfo</code>类可以遍历一个类中的所有属性。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/04/JAVA8学习（四）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-03T14:59:45.000Z"><a href="/2016/06/03/JAVA8学习（三）/">2016-06-03</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/03/JAVA8学习（三）/">JAVA8学习（三）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="lambda编程"><a href="#lambda编程" class="headerlink" title="lambda编程"></a>lambda编程</h2><ul>
<li><p>延迟执行：所有的lambda表达式都是延迟执行的。如果你需要立即执行某一段代码，就没必要使用lambda表达式了。延迟执行的原因有多种：</p>
<ul>
<li>在另一个线程中运行代码。</li>
<li>多次运行代码。</li>
<li>在某个算法的正确点上运行代码（排序中的比较）</li>
<li>当某些情况发生时运行代码（按扭被点击，数据达到）</li>
<li>只有在需要的时候才运行代码。<br>以日志为例，如果一个日志传入了多个变量，则一般调用<code>info</code>时会先把变量累加起来，然后再判断是否需要输出<code>info级别</code>的日志，如果根本不需要，就完全不必要执行变量累加操作。所以，可以修改成<code>lambda</code>表达式：<pre><code>public static void info(Logger logger,Supplier&lt;String&gt; message){
    if(logger.isLoggable(level.INFO))
        logger.info(message.get());
}
</code></pre></li>
</ul>
<p>改造后，调用的方法如下：<code>logger.info(()-&gt;&quot;x:&quot;+x+&quot;,y:&quot;+y)</code></p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/03/JAVA8学习（三）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/3/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:www.52brt.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angularjs/">Angularjs</a><small>6</small></li>
  
    <li><a href="/tags/Bootstrap/">Bootstrap</a><small>5</small></li>
  
    <li><a href="/tags/DateTime/">DateTime</a><small>1</small></li>
  
    <li><a href="/tags/HBase/">HBase</a><small>1</small></li>
  
    <li><a href="/tags/JavaFX/">JavaFX</a><small>1</small></li>
  
    <li><a href="/tags/Nashorn/">Nashorn</a><small>1</small></li>
  
    <li><a href="/tags/Nodejs/">Nodejs</a><small>7</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>3</small></li>
  
    <li><a href="/tags/TinkerPop3/">TinkerPop3</a><small>1</small></li>
  
    <li><a href="/tags/ambari/">ambari</a><small>1</small></li>
  
    <li><a href="/tags/centos/">centos</a><small>7</small></li>
  
    <li><a href="/tags/centos6/">centos6</a><small>1</small></li>
  
    <li><a href="/tags/docker/">docker</a><small>3</small></li>
  
    <li><a href="/tags/eclipse/">eclipse</a><small>1</small></li>
  
    <li><a href="/tags/eclipse插件开发/">eclipse插件开发</a><small>1</small></li>
  
    <li><a href="/tags/elasticsearch/">elasticsearch</a><small>6</small></li>
  
    <li><a href="/tags/express/">express</a><small>4</small></li>
  
    <li><a href="/tags/hadoop/">hadoop</a><small>1</small></li>
  
    <li><a href="/tags/hexo/">hexo</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>15</small></li>
  
    <li><a href="/tags/java8/">java8</a><small>9</small></li>
  
    <li><a href="/tags/kafka/">kafka</a><small>1</small></li>
  
    <li><a href="/tags/lambda/">lambda</a><small>2</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>11</small></li>
  
    <li><a href="/tags/markdown/">markdown</a><small>2</small></li>
  
    <li><a href="/tags/maven/">maven</a><small>1</small></li>
  
    <li><a href="/tags/mongodb/">mongodb</a><small>9</small></li>
  
    <li><a href="/tags/mysql/">mysql</a><small>1</small></li>
  
    <li><a href="/tags/nodejs/">nodejs</a><small>1</small></li>
  
    <li><a href="/tags/scala/">scala</a><small>7</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>5</small></li>
  
    <li><a href="/tags/stream/">stream</a><small>2</small></li>
  
    <li><a href="/tags/svg/">svg</a><small>1</small></li>
  
    <li><a href="/tags/titan/">titan</a><small>1</small></li>
  
    <li><a href="/tags/tomcat/">tomcat</a><small>1</small></li>
  
    <li><a href="/tags/其他/">其他</a><small>1</small></li>
  
    <li><a href="/tags/前端/">前端</a><small>17</small></li>
  
    <li><a href="/tags/可视化/">可视化</a><small>1</small></li>
  
    <li><a href="/tags/图数据库/">图数据库</a><small>1</small></li>
  
    <li><a href="/tags/多线程/">多线程</a><small>1</small></li>
  
    <li><a href="/tags/恢复/">恢复</a><small>1</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>9</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 okuc
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>