<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的后院自留地</title>
  <meta name="author" content="okuc">
  
  <meta name="description" content="hadoop hive hbase cassandra linux elasticsearch eclipse java mysql">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="我的后院自留地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="我的后院自留地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7ea69d6de48b6d7cd2a53bcc519beadc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">我的后院自留地</a></h1>
  <h2><a href="/">琴棋书画诗酒花 当年件件不离它 而今事事都变更 柴米油盐酱醋茶</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="//">首页</a></li>
    
      <li><a href="//archives">归档</a></li>
    
      <li><a href="//coding">编程技术</a></li>
    
      <li><a href="//bigData">大数据技术</a></li>
    
      <li><a href="//dataV">数据可视化</a></li>
    
      <li><a href="//about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-22T14:59:45.000Z"><a href="/2016/06/22/外网访问内网kafka访问不到问题的解决/">2016-06-22</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/22/外网访问内网kafka访问不到问题的解决/">JAVA程序员学习Scala（一）</a></h1>
  

    </header>
    <div class="entry">
      
        <p>由于需要在外网访问内网kafka，所以在公司的网络出口处做了端口映射，对kafka所需要9092，zookeeper所需的2181端口都做了映射。但是仍然无法访问，报了以下错误：</p>
<pre><code>2016-06-22 05:49:18.237-[ProducerSendThread-]- WARN {kafka.utils.Logging$class:89}-Failed to send producer request with correlation id 4073 to broker 0 with data for partitions [TOPIC_,0],[TOPIC_My,0]
java.nio.channels.ClosedChannelException
        at kafka.network.BlockingChannel.send(BlockingChannel.scala:100)
        at kafka.producer.SyncProducer.liftedTree1$1(SyncProducer.scala:73)
        at kafka.producer.SyncProducer.kafka$producer$SyncProducer$$doSend(SyncProducer.scala:72)
        at kafka.producer.SyncProducer$$anonfun$send$1$$anonfun$apply$mcV$sp$1.apply$mcV$sp(SyncProducer.scala:103)
        at kafka.producer.SyncProducer$$anonfun$send$1$$anonfun$apply$mcV$sp$1.apply(SyncProducer.scala:103)
        at kafka.producer.SyncProducer$$anonfun$send$1$$anonfun$apply$mcV$sp$1.apply(SyncProducer.scala:103)
        at kafka.metrics.KafkaTimer.time(KafkaTimer.scala:33)
        at kafka.producer.SyncProducer$$anonfun$send$1.apply$mcV$sp(SyncProducer.scala:102)
        at kafka.producer.SyncProducer$$anonfun$send$1.apply(SyncProducer.scala:102)
        at kafka.producer.SyncProducer$$anonfun$send$1.apply(SyncProducer.scala:102)
        at kafka.metrics.KafkaTimer.time(KafkaTimer.scala:33)
</code></pre><p> 或者如下错误：</p>
<pre><code>Exception in thread &quot;main&quot; kafka.common.FailedToSendMessageException: Failed to send messages after 3 tries.
    at kafka.producer.async.DefaultEventHandler.handle(DefaultEventHandler.scala:90)
    at kafka.producer.Producer.send(Producer.scala:77)
    at kafka.javaapi.producer.Producer.send(Producer.scala:33)
</code></pre><p> 但是，如果我在内网环境中，通过外网ip访问，则没有问题。经过排查，最终解决了该问题，原因如下：<strong>在设置config/server.properties配置文件时，将host.name参数设置为了该机器的ip，导到与客户端交互时，将该内网ip带到了外网，从而出现的问题。</strong><br> 解决方案如下：<br> <strong>将config/server.properties配置文件中的host.name参数设置为该机器的机器名，同时，在客户端机器上设置hosts文件，将该机器名对应的ip设为外网映射端口的ip，即可。或者不设该参数，统一使用机器名来访问（外网需设hosts文件）</strong></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-20T14:59:45.000Z"><a href="/2016/06/20/JAVA8学习（八）/">2016-06-20</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/20/JAVA8学习（八）/">JAVA8学习（八）</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><strong>字符串连接</strong>：<pre><code>String joined = String.join(&quot;/&quot;,&quot;usr&quot;,&quot;local&quot;,&quot;bin&quot;);//&quot;usr/local/bin&quot;;
System.out.println(joined);
String ids = String.join(&quot;,&quot;,ZoneId.getAvailableZoneIds());
System.out.println(ids);//将所有的时区标识，由逗号分隔
</code></pre></li>
<li><code>java5</code>中，7种原始类型的包装类（不包含Boolean）都提供了一个静态字段<code>SIZE</code>，用来表示该类型以<code>bit</code>为单位的长度。在<code>Java8</code>中，它们都提供了一个<code>BYTES</code>字段，以<code>byte</code>为单位来表过该类型的长度，以便于用于无法被8整除的情况。</li>
<li>为了在流操作中进行聚合操作，<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>和<code>Double</code>这5种类型，现在分别提供了静态方法<code>sum</code>、<code>max</code>、<code>min</code>，用来在流操作中作为聚合函数使用。出于相同的原因，<code>Boolean</code>类现在也包含了静态方法<code>logicalAnd</code>、<code>logicalOr</code>、<code>logicalXor</code>。</li>
<li><code>Integer</code>类现在支持无符号数学计算。静态方法<code>Byte.toUnsignedInt(b)</code>来获取一个从<code>0</code>到<code>255</code>的值。一般使用无符号数字，会丢失负数并获得原来两范围的正数。<code>Byte</code>和<code>Short</code>类中添增了<code>toUnsignedInt</code>方法，而<code>Byte</code>、<code>Short</code>、<code>Integer</code>类中新增了<code>toUnsignedLong</code>方法。</li>
<li><code>Integer</code>和<code>Long</code>类中新增了处理无符号值的<code>compareUnsigned</code>、<code>divideUnsigned</code>和<code>remainderUnsigned</code>方法。由于大于<code>Integer.MAX_VALUE</code>的无符号整数相乘会导致溢出，所以应该调<code>toUnsignedLong</code>将它们作为长整型值相乘。</li>
<li><code>Float</code>和<code>Double</code>类现在新增了静态方法<code>isFinite</code>,如果<code>x</code>不是正无穷大、负无穷大或者<code>NaN</code>(非数字)，那么<code>Double.isFinite(x)</code>将返回<code>true</code>。</li>
<li><code>BigInteger</code>类增加了实例方法<code>（long|int|short|byte）ValueExact</code>，分别用来返回<code>long</code>、<code>int</code>、<code>short</code>或者<code>byte</code>，并且当值不在目标范围内时抛出一个<code>ArithmeticExcepiont</code>异常。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/20/JAVA8学习（八）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-10T14:59:45.000Z"><a href="/2016/06/10/JAVA8学习（七）/">2016-06-10</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/10/JAVA8学习（七）/">JAVA8学习（七）</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><code>java8</code>提供了一个命令行工具<code>jjs</code>。你只需要启动它，并执行<code>JavaScript</code>命令即可启动：<pre><code>jjs
jjs&gt;&apos;Hello,World&apos;
Hello,World
jjs&gt;&apos;Hello,World.length
5
</code></pre></li>
<li>在<code>js</code>中定义字符串可以是单引号也可以是双引号。每行后边可以加分号也可以不加。</li>
<li>在<code>jjs</code>中定义函数并调用它们<pre><code>jjs&gt;function factorial(n){return n&lt;=1?1:n*factorial(n-1)}
function factorial(n){return n&lt;=1?1:n*factorial(n-1)}
jjs&gt;factorial(10)
3628800
</code></pre>-<code>jjs</code>中调用<code>java</code>的方法<pre><code>var input = new java.util.Scanner(new java.net.URL(&apos;http://horstmann.com&apos;).openStream())
input.useDelimiter(&apos;$&apos;)
var contents = input.next()
contents
</code></pre></li>
<li><code>jjs</code>又被称为<code>REPL</code>，可以用这种方式来学习<code>java API</code>，但是它没有<code>Scala</code>做得那么好。因为它的自动提示不友好，不能提示。可以尝试安装<code>rlwrap jjs</code>或在<code>Emacs</code>中运行<code>jjs</code>来解决这一问题。</li>
<li>在<code>Java</code>中，可以使用<code>Java6</code>中引入的脚本引擎机制来运行一个<code>Nashorn</code>脚本。通过脚本引擎，可以执行任何JVM语言的脚本，如<code>Groovy</code>、<code>JRuby</code>、<code>Jython</code>。此外，还有另外一些脚本引擎用于支持任何<code>JVM</code>以外的语言，如<code>PHP</code>、<code>Scheme</code>。</li>
<li><code>java8</code>中运行<code>nashorn</code>的示例如下：<pre><code>ScriptEngineManager manager = new ScriptEngineManager();//获取注册的引擎管理器
ScriptEngin engin = manager.getEngineByName(&quot;nashorn&quot;);//通过名称获取指定引擎
Object result = engine.vale(&quot;&apos;Hello,world!&apos;.length&quot;);
System.out.println(result);
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/10/JAVA8学习（七）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-09T14:59:45.000Z"><a href="/2016/06/09/JAVA8学习（六）/">2016-06-09</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/09/JAVA8学习（六）/">JAVA8学习（六）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><ul>
<li><code>java5</code>提供了强大的<code>java.util.concurrent</code>包，该包为我们提供了线程安全的集合和线程池，使得许多应用开发人员不必使用锁或者启动新线程，就可以编写并发程序。</li>
<li><code>java5</code>开始<code>java.util.concurrent.atomic</code>包提供了用于支持无锁可变变量的类，保证多线程并发访问同一个实例，也能正确计算并返回正确的值。如：<pre><code>public static AtomicLong nextNumber = new AtomicLong();
//在某些线程中
long id= nexNumber.incrementAndGet();//会自动将AtomicLong的值加1，并返回增加后的值。
</code></pre></li>
<li><p><code>java5</code>中提供了很多设置、增加、减少值的原子操作，但是如果想要进行更复杂的更新操作，必须使用<code>compareAndSet</code>方法。如想追踪由不同线程所监测的最大值，则下面的代码是行不通的：</p>
<pre><code>public static AtomicLong nextNumber = new AtomicLong();
//在某些线程中
largest.set(Math.max(largest.get(),observed)) //错误，竟争条件，非原子性操作。

do{
    oldValue = largest.get();
    newValue = Math.max(oldValue,observed);
}while(!largest.compareAndSet(oldValue,newValue));//正确方式，每个线程每次都取新旧值判断，只有符合要求时才会赋值。如果是java8,可以如下写：
largest.updateAndGet(x-&gt;Math.max(x,observed));
largest.accumulateAndGet(observed,Math::max);//accumulateAndGet方法通过一个二元运算符将原子值和传入的参数组合起来。
</code></pre><p>除了它之外，Java8还提供了返回原始值的<code>getAndUpdate</code>方法和<code>getAndaccumulateAndGet</code>方法。</p>
</li>
<li><code>AtomicInteger</code>、<code>AtomicIntegerArray</code>、<code>AtomicIntegerFieldupdater</code>、<code>AtomicLongArray</code>、<code>AtomicLongFieldUpdater</code>、<code>AtomicRefernce</code>、<code>AtomicReferenceArray</code>和<code>AtomicReferenceFieldUpdater</code>类都提供了这些方法。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/09/JAVA8学习（六）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-08T14:59:45.000Z"><a href="/2016/06/08/JAVA8学习（五）/">2016-06-08</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/08/JAVA8学习（五）/">JAVA8学习（五）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h2><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><ul>
<li><code>Java</code>日期和时间<code>API</code>规范要求<code>Java</code>使用如下年1月1日， 时标：<ul>
<li>每天都有<code>86400</code>秒</li>
<li>每天正午与官方时间准确匹配</li>
<li>其他时间也要以一种精确定义的方式与其紧密匹配</li>
</ul>
</li>
<li><code>Java</code>中，一个<code>Instant</code>对象表示时间轴上的一个点。原点（元年）为<code>1970</code>,<code>UNIX/POSIX</code>时间也使用了一样的约定。从86400秒进行计算，向前向后分别以纳秒为单位。</li>
<li><code>Instant</code>的最大值（<code>Instant.MAX</code>）表示<code>1000000000年的12月31日</code>。静态方法<code>Instant.now()</code>会近回当前的瞬时点。可以使用<code>equals</code>和<code>compareTo</code>方法来比较两个瞬时点，以便将它们作为时间戳使用。</li>
<li>要计算两个瞬时点之间的时间距离，你可以使用静态方法Duration.between.<pre><code>Instant start = Instant.now();
runAlgorithm();
Instant end = Instant.now();
Duration timeElapsed = Duration.between(start,end);
long millis = timeElapsed.toMillis();
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/08/JAVA8学习（五）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-04T14:59:45.000Z"><a href="/2016/06/04/JAVA8学习（四）/">2016-06-04</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/04/JAVA8学习（四）/">JAVA8学习（四）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h2><ul>
<li>在javaFx中，你可以在一个场景上放置任何你想要展现的东西。因此，你可以设计“演员”—即控件的形状的样式和行为。</li>
<li>场景需要舞台，如果运行在桌面系统上，舞台就是一个顶经的窗口，如果作为一个applet运行，舞台就是一个长方形的区域。</li>
<li>在任何Application类的子类中，我们都必须重写start方法，然后将场景作为一个参数传递给start方法。</li>
</ul>
<p>Button red = new Button(“red”);<br>red.setOnAction(event-&gt;message.setTextFile(Color.REd));</p>
<ul>
<li><p>对于大多数JavaFX控件来说，它们的事件处理方式是不同的，以一个滑块为例，当滑块被调整时，它的值就会发生改变。但是，不应该监听滑块发出的表示这些改变的底层事件，相反，滑块有个个JavaFX属性value，该属性会在发生改变时发起事件。<br><code>slider.valueProperty().addListener(property-&gt;message.setFont(new Font(slider.getValue())))</code><br>-<code>java.beans</code>包中的<code>Introspector</code>和<code>BeanInfo</code>类可以遍历一个类中的所有属性。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/04/JAVA8学习（四）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-03T14:59:45.000Z"><a href="/2016/06/03/JAVA8学习（三）/">2016-06-03</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/03/JAVA8学习（三）/">JAVA8学习（三）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="lambda编程"><a href="#lambda编程" class="headerlink" title="lambda编程"></a>lambda编程</h2><ul>
<li><p>延迟执行：所有的lambda表达式都是延迟执行的。如果你需要立即执行某一段代码，就没必要使用lambda表达式了。延迟执行的原因有多种：</p>
<ul>
<li>在另一个线程中运行代码。</li>
<li>多次运行代码。</li>
<li>在某个算法的正确点上运行代码（排序中的比较）</li>
<li>当某些情况发生时运行代码（按扭被点击，数据达到）</li>
<li>只有在需要的时候才运行代码。<br>以日志为例，如果一个日志传入了多个变量，则一般调用<code>info</code>时会先把变量累加起来，然后再判断是否需要输出<code>info级别</code>的日志，如果根本不需要，就完全不必要执行变量累加操作。所以，可以修改成<code>lambda</code>表达式：<pre><code>public static void info(Logger logger,Supplier&lt;String&gt; message){
    if(logger.isLoggable(level.INFO))
        logger.info(message.get());
}
</code></pre></li>
</ul>
<p>改造后，调用的方法如下：<code>logger.info(()-&gt;&quot;x:&quot;+x+&quot;,y:&quot;+y)</code></p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/03/JAVA8学习（三）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-02T14:59:45.000Z"><a href="/2016/06/02/JAVA8学习（二）/">2016-06-02</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/02/JAVA8学习（二）/">JAVA8学习（二）</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h2><ul>
<li><p>要统计一本书的长单词，做法如下：</p>
<pre><code>String contents = new String(Files.readAllBytes(Paths.get(&quot;alice.txt&quot;)),StandardCharsets.UTF_8);
List&lt;String&gt; words = Arrays.asList(contents.split(&quot;[\\P{L}]+&quot;));//将字符串分隔成字母，非字母被认为是分隔符

//传统方式
int count=0;
for(String w:words){
    if(w.length()&gt;12)count++;
}

//java8方式
long count= words.stream().filter(w-&gt;w.lenght()&gt;12).count();
</code></pre></li>
<li><p><code>Stream</code>与集合的区别如下：</p>
<ul>
<li><code>Stream</code>自已不会存储元素。元素可能被存储在底层的集合中，或者根据需要产生出来。</li>
<li><code>Stream</code>操作符不会改变源对象。它们会返回一个持有结果的新的Stream。</li>
<li><code>Stream</code>是<strong>延迟执行</strong>的。就是说，他们在需要结果的时候才会执行。</li>
</ul>
</li>
<li><p><code>stream</code>与<code>parallelStream</code>的区别是，后者可以并行执行过滤和统计操作。</p>
<pre><code>//java8方式
long count= words.parallelStream().filter(w-&gt;w.lenght()&gt;12).count();
</code></pre></li>
<li><p>使用<code>stream</code>，会通过三个阶段来建立一个操作流水线：</p>
<ol>
<li>创建一个<code>stream</code>。</li>
<li>在一个或多个步骤中，指定将初始<code>stream</code>转换为另一个<code>stream</code>的中间操作。</li>
<li>使用一个终止操作来产生一个结果。该操作会强制它之前的延迟操作立即执行。在这之后，该<code>Stream</code>就不会再被使用了。</li>
</ol>
</li>
<li><p><code>stream</code>操作不会按元素的顺序调用执行。</p>
</li>
<li>数组也可以转化为<code>stream</code>。<code>Stream.of(contents.split(&quot;[\\P{L}]+&quot;))</code>;<code>of</code>方法可接收一个可变长度的参数，因此可构造任意个参数的<code>Stream</code>。<code>Stream&lt;String&gt; song = Stream.of(&quot;gently&quot;,&quot;down&quot;,&quot;the&quot;,&quot;stream&quot;);</code>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/02/JAVA8学习（二）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-22T14:35:02.000Z"><a href="/2016/05/22/shell学习(五)/">2016-05-22</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/22/shell学习(五)/">shell学习(五)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="linux中的信号"><a href="#linux中的信号" class="headerlink" title="linux中的信号"></a>linux中的信号</h2><ul>
<li>软中断</li>
<li>进程间异步通信</li>
<li><code>man 7 signal</code> 查看系统中对信号的支持</li>
<li>键盘组合键生成信号<ul>
<li>终止进程： <code>SIGINT</code> <code>Ctrl+C</code></li>
<li>暂停进程： <code>SIGSTP</code> <code>Ctrl+Z</code></li>
</ul>
</li>
<li><code>man kill</code> ：查看kill命令的帮助</li>
<li>程序中的信号处理<ul>
<li>按照默认方式处理信号</li>
<li>忽略信号</li>
<li>按照自定义方式捕捉并处理信号
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/05/22/shell学习(五)/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-05-20T14:35:02.000Z"><a href="/2016/05/20/shell学习(三)/">2016-05-20</a></time>
      
      
  
    <h1 class="title"><a href="/2016/05/20/shell学习(三)/">shell学习(三)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="shell中的输入输出重定向"><a href="#shell中的输入输出重定向" class="headerlink" title="shell中的输入输出重定向"></a>shell中的输入输出重定向</h2><ul>
<li>标准输入是键盘，标准输出是终端显示器。</li>
<li>输出重定向<ul>
<li><code>command &gt; outputfile</code> //大于号两端要有空格分开</li>
<li><code>command &gt;&gt; outputfile</code></li>
</ul>
</li>
<li><p>一个例子</p>
<pre><code>echo 22222 &gt; ./iotest
echo 111 &gt; ./iotest //会把上一行覆盖掉
echo 111 &gt;&gt; ./iotest //不会覆盖掉原有数据，会新起一行
</code></pre></li>
<li>输入重定向<ul>
<li><code>command &lt; outputfile</code></li>
</ul>
</li>
<li>例子： <code>cat &lt; iotest &gt; iotest2</code></li>
<li><p>内联输入重定向</p>
<pre><code>command &lt;&lt; marker
data input
marker
</code></pre></li>
<li><p>例子：</p>
<pre><code>result = `bc &lt;&lt; EOF
&gt;var1=3
&gt;var2=4
&gt;var3=var1+var2
&gt;print var3
&gt;EOF`

echo $result
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/05/20/shell学习(三)/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angularjs/">Angularjs</a><small>6</small></li>
  
    <li><a href="/tags/Bootstrap/">Bootstrap</a><small>5</small></li>
  
    <li><a href="/tags/DateTime/">DateTime</a><small>1</small></li>
  
    <li><a href="/tags/HBase/">HBase</a><small>1</small></li>
  
    <li><a href="/tags/JavaFX/">JavaFX</a><small>1</small></li>
  
    <li><a href="/tags/Nashorn/">Nashorn</a><small>1</small></li>
  
    <li><a href="/tags/Nodejs/">Nodejs</a><small>7</small></li>
  
    <li><a href="/tags/TinkerPop3/">TinkerPop3</a><small>1</small></li>
  
    <li><a href="/tags/centos/">centos</a><small>7</small></li>
  
    <li><a href="/tags/centos6/">centos6</a><small>1</small></li>
  
    <li><a href="/tags/docker/">docker</a><small>3</small></li>
  
    <li><a href="/tags/eclipse/">eclipse</a><small>1</small></li>
  
    <li><a href="/tags/eclipse插件开发/">eclipse插件开发</a><small>1</small></li>
  
    <li><a href="/tags/elasticsearch/">elasticsearch</a><small>6</small></li>
  
    <li><a href="/tags/express/">express</a><small>4</small></li>
  
    <li><a href="/tags/hexo/">hexo</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>10</small></li>
  
    <li><a href="/tags/java8/">java8</a><small>8</small></li>
  
    <li><a href="/tags/kafka/">kafka</a><small>1</small></li>
  
    <li><a href="/tags/lambda/">lambda</a><small>2</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>11</small></li>
  
    <li><a href="/tags/markdown/">markdown</a><small>2</small></li>
  
    <li><a href="/tags/maven/">maven</a><small>1</small></li>
  
    <li><a href="/tags/mongodb/">mongodb</a><small>9</small></li>
  
    <li><a href="/tags/mysql/">mysql</a><small>1</small></li>
  
    <li><a href="/tags/nodejs/">nodejs</a><small>1</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>5</small></li>
  
    <li><a href="/tags/stream/">stream</a><small>2</small></li>
  
    <li><a href="/tags/svg/">svg</a><small>1</small></li>
  
    <li><a href="/tags/titan/">titan</a><small>1</small></li>
  
    <li><a href="/tags/tomcat/">tomcat</a><small>1</small></li>
  
    <li><a href="/tags/前端/">前端</a><small>17</small></li>
  
    <li><a href="/tags/可视化/">可视化</a><small>1</small></li>
  
    <li><a href="/tags/图数据库/">图数据库</a><small>1</small></li>
  
    <li><a href="/tags/多线程/">多线程</a><small>1</small></li>
  
    <li><a href="/tags/恢复/">恢复</a><small>1</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>9</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 okuc
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>