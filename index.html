<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的后院自留地</title>
  <meta name="author" content="okuc">
  
  <meta name="description" content="hadoop hive hbase cassandra linux elasticsearch eclipse java mysql spark titan tinkpop neo4j">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="我的后院自留地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="我的后院自留地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7ea69d6de48b6d7cd2a53bcc519beadc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">我的后院自留地</a></h1>
  <h2><a href="/">琴棋书画诗酒花 当年件件不离它 而今事事都变更 柴米油盐酱醋茶</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="//">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/coding">编程技术</a></li>
    
      <li><a href="/bigData">大数据技术</a></li>
    
      <li><a href="/dataV">数据可视化</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-10-23T14:59:45.000Z"><a href="/2016/10/23/快学scala《六》/">2016-10-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/10/23/快学scala《六》/">快学scala六</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><ol>
<li><p>变量、函数、类等的名称统称为标识符。scala中可以使用java的方式：<code>字母和数字字符的序列，以字母或下画线开头</code>，比如<code>fred12</code>或者<code>_Wilma</code>。可以使用<code>Unicode</code>字符。除此之外，还可以使用下列的任意字符：</p>
<ul>
<li>除字母、数字、下画线、括号<code>()[]{}</code>或分隔符<code>.,;&#39;``&quot;</code>之外的<code>ASCII</code>字符。即如下这些：<code>！#%&amp;*+-/:&lt;=&gt;?@\^|~</code></li>
<li><code>Unicode</code>的数学符号，或<code>Unicode</code>的<code>Sm</code>和<code>So</code>类别中的其他符号。如： <code>val √ = scala.math.sqrt _</code>,然后就可以用<code>√(2)</code>来计算平方根。</li>
<li>可以在反引号中包含几乎任何符号序列来使用。当然一般不这么做，但是当scala和java中关键字冲突时，可以这么做来使用java中的方法：Thread.<code>yield</code>()</li>
</ul>
</li>
<li><p>中置操作符：<code>a 标识符 b</code>，其中标识符代表一个带有两个参数的方法(一个隐式的参数和一个显式的参数)<br><code>1 to 10</code>，<code>1-&gt;10</code>。<br>要定义自已的操作符如下,根据以下法则来计算两个分数的乘积：</p>
<pre><code>(n1/d1)X(n2/d2)=(n1n2/d1d2)

class Fraction(n:Int,d:Int){
    private int num = ...
    private int den = ...
    ...
    def *(other:Fraction) = new Fraction(num*other.num,den*other.den)
}
</code></pre></li>
<li><p>一元操作符：<code>中置操作符是二元的</code>，它们有两个参数。只有一个参数的操作符称为一元操作符。如果它出现在参数之后，那么它就是一个<code>后置(Postfix)操作符</code>：<br> <code>a 标识符</code> 等价于 <code>a.标识符()</code><br>如下四个操作符<code>+、-、!、~</code>可以作为<code>前置(prefix)操作符</code>，出现在参数之前，它们被转换成对名为<code>unary_</code>操作符的方法的调用。如：<code>-</code>a 等价于：<code>a.unary_-</code>一样。</p>
<p>赋值操作符的名称形式为<code>操作符=</code>,以下表达式：<br><code>a 操作符= b</code> 等价于： <code>a = a 操作符 b</code><br>注意：</p>
<ul>
<li>&lt;=、 &gt;= 、 !=不是赋值操作符</li>
<li>以=开头的操作符不是赋值操作符(==、===、=/=)</li>
<li>如果a有一个名为<code>操作符=</code>的方法，那么该方法会被直接调用.</li>
</ul>
</li>
<li><p>操作符的优先及如下：<code>*、/、%</code>、<code>+、-</code>、<code>:</code>、<code>&lt;&gt;</code>、<code>!=</code>、<code>&amp;</code>、<code>^</code>、<code>|</code>、<code>非操作符</code>。 <code>赋值操作符</code><br><code>后置操作符的优先级低于中置操作符。</code></p>
</li>
<li><p>在Scala中，大部分的操作符是<code>左结合</code>的，如：<code>17-2+9</code>，计算方式为<code>(17-2+9)</code>。以下操作符是<code>右结合</code>的：以<code>冒号(:)</code>结尾的操作符，赋值操作符，如：<br><code>1::2::Ni1</code> 的意思是<code>1::(2::Ni1)</code>,<code>右结合</code>的二元操作符是其第二个参数的方法，如：<code>2::Ni1</code>的意思是：<code>Ni1.::(2)</code></p>
</li>
<li><p>在scala中，<code>f(arg1,arg2,...)</code>这样的函数调用语法，如果<code>f不是函数或方法，那么这个表达式就等同于调用f.apply(arg1,arg2,...)</code>,除非它出现在赋值语句的等号左侧。表达式<code>f(arg1,arg2,...) = value</code>,等价于<code>f.update(arg1,arg2,...,value)</code>,这个机制被用于数组和映射。如：</p>
<pre><code>val scores = new scala.collection.mutable.HashMap[String,Int]
scores(&quot;Bob&quot;) = 100 //调用scores.update(&quot;Bob&quot;,100)
val bobsScore = scores(&quot;Bob&quot;)//调用Scores.apply(&quot;Bob&quot;)
</code></pre><p>apply方法经常被用在伴生对象中，用来构造对象而不用显式地使用new。如：</p>
<pre><code>class Fraction(n:Int,d:Int){
    ...
}
object Fraction{
    def apply(n:Int,d:Int) = new Fraction(n,d)
}
</code></pre><p>定义后，可以用<code>Fraction(3,4)</code>来构造分数，而不是用<code>new Fraction(3,4)</code></p>
</li>
<li><p><code>unapply</code>方法当做是伴生对象中<code>apply</code>方法的反向操作,<code>apply</code>方法接受构造参数，然后将它们变成对象；而<code>unapply</code>方法接收一个对象，然后从中提取值。如在变量定义时取出分子和分母：</p>
<pre><code>var Fraction(a,b) = Fraction(3,4)*Fraction(2,5)//a和b分别被初始化成运算结果的分子和分母
</code></pre><p>或者用于模式匹配：</p>
<pre><code>case Fraction(a,b) =&gt; ... //a和b分别被绑定到分子和分母
</code></pre><p>如果模式匹配失败，<code>unapply</code>方法返回的是一个<code>Option</code>。它包含一个元组，每个匹配到的变量各有一个值与之对应。如：</p>
<pre><code>Object Fraction{
   def unapply(input:Fraction) = 
       if(input.den == 0 ) None else Some ((input.num,input.den))//0表示分母为0时无匹配
}

val author = &quot;Cay Horstmann&quot;
val Name(first,last) = author //调用Name.unapply(author)

object Name{
   def unapply(input:String) = {
       val pos = input.indexOf(&quot; &quot;)
       if(pos == -1) None
       else Some((input.substring(0,pos),input.substring(pos+1)))
   }
}

case Currency(amount,&quot;USD&quot;) =&gt; println(&quot;$&quot;+amount) //将调用Currency.unapply
</code></pre></li>
<li><p>如果<code>unapply</code>方法要提取单值，则它应该返回一个目标类型的<code>Option</code>。如：</p>
<pre><code>object Number{
    def unapply(input:String)Option[Int]=
    try{
        Some(Integer.parseInt(input.trim))
    }catch{
        case ex:NumberFormatException =&gt;None
    }
}

val Number(n) = &quot;1234&quot; //提取数字
</code></pre><p>也可以只是测试输入并不真的将值提取出来，这样<code>unapply</code>方法应返回<code>Boolean</code>，如：</p>
<pre><code>object IsCompound{
    def unapply(input:String)=input.contains(&quot; &quot;)
}

author match{
    case Name(first,last@IsCompound())=&gt;...//如果作者是Peter van der Linden也能成功匹配
    case Name(first,last)=&gt;...
}
</code></pre></li>
<li><p>要提取任意长度的序列，可以使用unapplySeq方法，它返回值是Option[Seq[A]],其中A是被提取的值的类型：</p>
<pre><code>object Name{
    def unapplySeq(input:String):Option[Seq[String]]=
        if(input.trim ==&quot;&quot;)None else Some(input.trim.split(&quot;\\s+&quot;))
}

author math{
    case Name(first,last)=&gt;...
    case Name(first,middle,last)=&gt;...
    case Name(first,&quot;van&quot;,&quot;der&quot;,last)=&gt;...
}
</code></pre></li>
</ol>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ol>
<li><p>在Scala中，可以在变量中存放函数：</p>
<pre><code>import scala.math._ 
val num = 3.14
val fun = ceil _
</code></pre><p>上述代码将<code>num</code>设为<code>3.14</code>，将<code>fun</code>设为<code>ceil</code>函数，后边的<code>_</code>意味着确实指的是这个函数，而不是忘记了给它传参数。</p>
<pre><code>fun(num) //4.0
Array(3.14,1.42,2.0).map(fun) //Array(4.0,2.0,2.0)
</code></pre></li>
<li><p>匿名函数：<code>(x:Double)=&gt;3*x</code>,该函数将传给它的参数乘以3</p>
<p><code>val tripe = (x:Double)=&gt;3*x</code> 等价于  <code>def triple(x:Double)=&gt;3*x</code><br><code>Array(3.14,1.42,2.0).map((x:Double)=&gt;3*x)</code> 等价于   <code>Array(3.14,1.42,2.0).map{(x:Double)=&gt;3*x}</code>cx</p>
</li>
<li><p>带函数参数的函数</p>
<pre><code>def valueAtOneQuarter(f:(Double)=&gt;Double) = f(0.25)//定义一个函数，它接受任何Double类型的参数并返回Double的函数,它的类型是((Double)=&gt;Double)=&gt;Double
valueAtOneQuarter(ceil _) //1.0
valueAtOneQuarter(sqrt _)//0.5

def mulBy(factor:Double) = (x:Double)=&gt;factor*x //它的类型是(Doutble)=&gt;((Double)=&gt;Double),接受Double类型 参数，返回一个函数,mulBy(2)(3)
</code></pre></li>
<li><p>类型推断：当一个匿名函数传递给另一个函数或方法时，Scala会尽可能帮你推断出类型信息，如：</p>
<pre><code>valueAtOneQuarter(x=&gt;3*x)  //如果参数在=&gt;右侧只出现了一次，可以用_来代替：valueAtOneQuarter(3*_)
val fun = 3*_错误：无法推断出类型
val fun = 3*(_:Double)//ok
val fun:(Double)=&gt;Double = 3*_ //ok，因为我们给出了fun的类型
</code></pre></li>
<li><p>一些有用的高阶函数：</p>
<pre><code>(1 to 9).map(&quot;*&quot; * _).foreach(println _) //打印三角型
(1 to 9).filter(_%2==0)//2,4,6,8
(1 to 9).reduceLeft(_ * _)//1*2*3*4*5*6*7*8*9
&quot;Mary has a little lamb&quot;.split(&quot; &quot;).sortWith(_.length &lt; _.length)//Array(&quot;a&quot;,&quot;had&quot;,&quot;Mary&quot;,&quot;lamb&quot;,&quot;little&quot;)
</code></pre></li>
<li><p>闭包：闭包中你的函数可以在变量不再处于作用域内时被调用。</p>
<pre><code>def mulBy(factor:Double)=(x:Double)=&gt;factor*x
val triple = mulBy(3)//factor为3，将(x:Double)=&gt;3*x存入triple
val half = mulBy(0.5)//factor为0.5，将(x:Double)=&gt;0.5*x存入half
println(triple(14)+&quot; &quot;+half(14)) //打印42  7.每个返回的函数都有自已的factor设置，这被称为闭包
</code></pre></li>
<li><p>告诉函数做某个事时，会传另一个函数给它，通常做法是将动作放在一个实现某接口的类中，然后将该类的一个实例传递给另一个方法。这些接口都只有单个抽象方法。在Java中它们被称为SAM类型。如按钮点击时递增一个计数器：</p>
<pre><code>var counter =0                     
val button=new JButton(&quot;Increment&quot;)
button.addActionListener(new ActionListener{
override def actionPerformed(event:ActionEvent){
counter += 1
}
})   

button.addActionListener((event:ActionEvent)=&gt;counter +=1)
</code></pre><p>要启用这个语法，需要提供一个隐式转换，下面是一个把函数转成ActionListener的实例：</p>
<pre><code>implicit def makeAction(action:(ActionEvent)=&gt;Unit) = 
new ActionListener{
    override def actionPerformed(event:actionEvent){action(event)}
}
</code></pre></li>
<li><p>柯里化指的是将原业接受两个参数的函数变成新的接受一个函数的过程。新的函数返回一个以原有第二个参数作为参数的函数。</p>
<pre><code>def mul(x:Int,y:Int) = x * y 
def mulOneAtAtime(x:Int) = (y:Int)=&gt;x*y//改造成接受一个参数，生成另一个接受单个参数的函数
mulOneAtATime(6)(7)

//另一个例子：
val a = Array(&quot;Hello&quot;,&quot;World&quot;)
val a = Array(&quot;Hello&quot;,&quot;World&quot;)
a.corresponds(b)(_.equalsIgnoreCase(_))  //def corresponds[B](that:Seq[B])(p:(A,B)=&gt;Boolean):Boolean
</code></pre></li>
<li><p>函数在线程中执行某段代码：</p>
<pre><code>def runInThread(block:()=&gt;Unit){
    new Thread{
        override def run(){block()}
    }.start
}

 runInThread{()=&gt;println(&quot;Hi&quot;);Thread.sleep(1000);println(&quot;Bye&quot;)}
</code></pre><p>要想省掉<code>()=&gt;</code>,可以使用换名调用表示法:在参数声明和调用该函数参数的地方略去<code>()</code>,但保留<code>=&gt;</code></p>
<pre><code>def runInThread(block:=&gt;Unit){
    new Thread{
        override def run(){block}
    }.start
}

 runInThread{println(&quot;Hi&quot;);Thread.sleep(1000);println(&quot;Bye&quot;)} 
</code></pre><p>另一个例子：</p>
<pre><code>def until(condition:=&gt;Boolean)(block:=&gt;Unit)
  if(!condition){
    block
    until(condition){block}
  }
 }

var x = 10
until(x==0){
x-=1
println(x)
}
</code></pre></li>
<li><p>在scala中，不需要用<code>return</code>语句返回函数值。函数的返回值就是函数体的值。</p>
<pre><code>def indexOf(str:String,ch:Char):Int = {
 var i=0
 until(i == str.length){
   if(str(i)==ch) return i
   i+=1
 }
 return -1
}
</code></pre></li>
</ol>
<p>匿名函数<code>{if(str(i)==ch)return i;i+=1}</code>被传递给<code>until</code>。当<code>return</code>表达式被执行时，包含它的带名函数<code>indexOf</code>终止并返回给定的值。<br>如果要在带名函数中使用<code>return</code>的话，则需要给出其返回类型。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-15T14:59:45.000Z"><a href="/2016/09/15/快学scala《五》/">2016-09-15</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/15/快学scala《五》/">快学scala五</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ol>
<li><p>按行读取文件</p>
<pre><code>import scala.io.Source
val source = Source.fromFile(&quot;myfile.txt&quot;,&quot;UTF-8&quot;)  //第一个参数为字符串或java.io.File,第二个为编码，可以忽略
val lineIterator = source.getLines//获取行的叠代器并进行处理
for(line&lt;-lineIterator) 处理line //还可以对迭代器应用toArray或toBuffer方法，将这些行放到数组或数组缓冲中

val lines = source.getLines.toArray

val contents = source.mkString //将整个文件读成一个字符串

source.close //关闭文件对象
</code></pre></li>
<li><p>按字符读取文件：</p>
<pre><code>for(c&lt;-source) 处理c
</code></pre><p>如果想查看某个字符，但又不处理它，可以如下操作：</p>
<pre><code>val source = Source.fromFile(&quot;myfile.txt&quot;,&quot;UTF-8&quot;)  //第一个参数为字符串或java.io.File,第二个为编码，可以忽略
val iter=source.buffered
while(iter.hasNext){
  if(iter.head 是符合预期的)
    处理iter.next
  else
    ...
}

val contents = source.mkString //如果文件不是很大，可以把它读成一个字符串进行处理
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/09/15/快学scala《五》/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-09T14:59:45.000Z"><a href="/2016/09/09/快学scala《四》/">2016-09-09</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/09/快学scala《四》/">快学scala四</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="包和引入"><a href="#包和引入" class="headerlink" title="包和引入"></a>包和引入</h2><ol>
<li><p>包：</p>
<pre><code>package com{
  package horstmann{
    package impatient{
      class Employee
      ...
    }
  }
}
</code></pre><p>上述的类<code>Employee</code>可以在任意的位置以<code>com.horstmann.impatient.Employee</code>访问</p>
<p>同一个包可以定义在多个文件中，如上述的包定义在<code>Employee</code>文件中，则<code>Manager.scala</code>文件也可定义此包：</p>
<pre><code>package com{
  package horstmann{
    package impatient{
      class Manager
      ...
    }
  }
}
</code></pre><p>源文件的目录和包之彰没有强制的关联关系，上述两个类可以放在不同的目录下，当然，在一个源文件中也可以有两个不同的包。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/09/09/快学scala《四》/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-04T14:59:45.000Z"><a href="/2016/09/04/正式启用新域名www.okuc.xyz/">2016-09-04</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/04/正式启用新域名www.okuc.xyz/">www.okuc.xyz</a></h1>
  

    </header>
    <div class="entry">
      
        <p>即日起原域名<a href="www.52brt.com">www.52brt.com</a>弃用，新域名<a href="www.okuc.xyz">www.okuc.xyz</a>正式启用。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-09-01T14:59:45.000Z"><a href="/2016/09/01/快学scala《三》/">2016-09-01</a></time>
      
      
  
    <h1 class="title"><a href="/2016/09/01/快学scala《三》/">快学scala三</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li><p>在<code>Scala</code>中，类并不声明为<code>public</code>。<code>Scala</code>源文件可以包含多个类，所有这些类都具有公有可见性。</p>
<p> calss Counter{<br>   private var value=0//必须初始化字段<br>   def increment(){ value +=1} //方法默认是公有的<br>   def current()=value<br> }</p>
<p>调用时，可以带括号，也可以不带。建议在改值器调用时添加小插号，对取值器不用。如果在定义中不使用小括号，那么使用者就必须用<code>MyCounter.current</code>，不带圆括号。</p>
</li>
<li><p><code>scala</code>对每个字段都提供<code>getter</code>和<code>setter</code>方法。如果我们对自动提供的这两个方法不满意，还可以重新定义。如果字段是<code>val</code>,则只会生成getter方法。若不需要这两个方法，则将字段声明为：<code>private[this]</code>，这个声明将导致本字段只能本对象可用，对于其他实例则不可用。<code>private[类名]</code>允许指定可以访问该字段的指定类的方法。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/09/01/快学scala《三》/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-21T14:59:45.000Z"><a href="/2016/07/21/制作centos6下的ambari离线安装源/">2016-07-21</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/21/制作centos6下的ambari离线安装源/">制作centos6下的ambari离线安装源</a></h1>
  

    </header>
    <div class="entry">
      
        <p>之前制用的ambari离线安装源比较久了，spark版片也较旧。最近想把一些工作迁移动spark上来，但发现之前制的ambari安装源spark版本太低，于是决定制作一个新的离线安装源。网络上关于怎么制作的教程也比较多了，可是感觉许多都不适合本人，总有遗漏的地方，所以就特意记录了此次制作方式。本次制作的安装源基于ambari2.2.1，所使用的linux为centos6.6，jdk版本为java8。</p>
<p>步聚如下：</p>
<ol>
<li><p>下载所需文件，建议使用迅雷下载，毕竟接近6个多G。下载地址如下：</p>
<ul>
<li>HDP2.4.0.0文件:<a href="http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.4.0.0/HDP-2.4.0.0-centos6-rpm.tar.gz">http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.4.0.0/HDP-2.4.0.0-centos6-rpm.tar.gz</a></li>
<li>HDP-UTILS1.1.0.20文件:<a href="http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6/HDP-UTILS-1.1.0.20-centos6.tar.gz">http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.20/repos/centos6/HDP-UTILS-1.1.0.20-centos6.tar.gz</a></li>
<li><p>ambari2.2.1文件文件:<a href="http://public-repo-1.hortonworks.com/ambari/centos6/2.x/updates/2.2.1.0/ambari-2.2.1.0-centos6.tar.gz">http://public-repo-1.hortonworks.com/ambari/centos6/2.x/updates/2.2.1.0/ambari-2.2.1.0-centos6.tar.gz</a></p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/07/21/制作centos6下的ambari离线安装源/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-15T14:59:45.000Z"><a href="/2016/07/15/快学scala《二》/">2016-07-15</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/15/快学scala《二》/">快学scala二</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><ol>
<li><p>定义长度不变的数组：</p>
<pre><code>var nums = new Array[Int](10) //10个整数的数组，所有元素初始化为0
var a = new Array[String](10)//10个元素的字符串数组，所有元素初始化为null
var s = Array(&quot;Hello&quot;,&quot;World&quot;)//长度为2的Array[String],类型是推导出来的，已提供初始值，不需要new
s(0)=&quot;Goodbye&quot;  //使用()而不是[]来访问元素
</code></pre></li>
<li><p>变长数组，<code>Java</code>有<code>ArrayList</code>，<code>C++</code>有<code>vector</code>。<code>Scala</code>中的等效数据结构为<code>ArrayBufferi</code></p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/07/15/快学scala《二》/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-07-04T14:59:45.000Z"><a href="/2016/07/04/快学scala《一》/">2016-07-04</a></time>
      
      
  
    <h1 class="title"><a href="/2016/07/04/快学scala《一》/">快学scala一</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1、在<code>Scala</code>中，每个表达式都有返回值和类型<code>val s= if(x&gt;0) 1 else -1</code></p>
<p>2、所有的类都继随于<code>Any</code>， 空类型为<code>Unit</code>，写作<code>()</code></p>
<p>3、语句终止不需要有分号，语句较长的话，要确保第一行以一下不能用作语句结尾的符号结尾。如`+。</p>
<p>4、<code>｛｝</code>块包含一系列的表达式。块中最后一个表达式的值就是块的值。<code>{r=rn;n-=1}</code>最后是一个赋值操作，所以这个块的返回值为<code>Unit</code>。java中赋值操作是有返回值的，返回值是这个赋的值</p>
<p>5、<code>print(“Answer:”+42),println(“aaa”);</code>还可以<code>printf(“Hello,%s!You are %d years old.\n”,”Fred”,42)</code><br>6、读取控制台输入：<br>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/07/04/快学scala《一》/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-26T14:59:45.000Z"><a href="/2016/06/26/JAVA程序员学习Scala（三）/">2016-06-26</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/26/JAVA程序员学习Scala（三）/">JAVA程序员学习Scala（三）</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><p><code>JUnit</code>和<code>TestNG</code>都可以用来测试<code>Scala</code>。<code>ScalaTest</code>是专门用来测试<code>Scala</code>的。下载地址如下：<a href="http://www.scalatest.org/">http://www.scalatest.org/</a></p>
<pre><code>class CanaryTest extends org.scalatest.Suite{    
    def testOK(){
        assert(true)
    }
}
(new CanaryTest).execute()
</code></pre></li>
<li><p><code>ScalaTest</code>提人工的<code>Runner</code>类可以用来执行多个测试套件。你可以指定<code>Runner</code>运行那些套件，不运行那些套件，还可以附加不同的<code>reporter</code>，用以显示测试结果。</p>
<pre><code>class ListTest extends org.scalatest.Suite{
    def testListEmpty(){
        var list = new java.util.ArrayList[Integer]
        assert(0==list.size)
    }

    def testListAdd(){
        val list = new java.util.ArrayList[Interger]
        list.add(1)
        list add 4
        assert(2 == list.size)
    }
}
</code></pre><p>使用如下命令进行编译并进行：</p>
<pre><code>scalac -classpath $SCALATEST ListTest.scala
scala -classpath $SCALATEST:. org.scalatest.tools.Runner -P .
</code></pre><p><code>-p</code>选项指定了<code>Runner</code>到那个目录下查找测试套件。因为我们没有指定某个具体的测试套件，所以它就会把给定路径下所有编译后的测试套件全部都装载进来。运行结果将会是一个界面<br>如果对命令行情有独钟，还可以用<code>-o</code>选项把测试执行结果定向到标准输出，而不是<code>GUI</code>显示。</p>
<pre><code>scalac -classpath $SCALATEST ListTest.scala
scala -classpath $SCALATEST:. org.scalatest.tools.Runner -P . -o
</code></pre><p><code>-f</code>选项还可以把结果重定义到文件。如果需要记录结果，在持续集成中进行处理，这个选项就相当有用。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/26/JAVA程序员学习Scala（三）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="coding">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-24T14:59:45.000Z"><a href="/2016/06/24/JAVA8学习（九）/">2016-06-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/06/24/JAVA8学习（九）/">JAVA8学习（九）</a></h1>
  

    </header>
    <div class="entry">
      
        <ul>
<li><strong>try-with-resources</strong> Java7提供了一个简单实用的代码格式，如下：<br>打开一个资源<pre><code>try{
    使用该资源
}finally{
    关闭该资源
}
</code></pre>其中资源所属的类必须实现了AutoCloseable接口。该接口只有一个方法：<code>void close() throws Exception</code><pre><code>try-with-resources语句的最简单形式如下所示：
try(Resource res = ...){
   使用res
}
</code></pre>当<code>try</code>语句块退出时，会自动调用<code>res.close()</code>方法。下面是一个经典示例—-读取一个文件中的所有单词：<pre><code>try(Scanner in = new Scanner(Paths.get(&quot;/usr/share/dict/words&quot;))){
   while(in.hasNext()) System.out.println(in.next().toLowerCase());
}
</code></pre>当代码块像往常一样退出或者发生异常时，都会调用<code>in.close()</code>方法，就如同之前<code>finally</code>一样<br>在Java7中，可以在同一个<code>catch</code>分支中捕获多个异常类型，如<code>catch(FileNotFoundException|UnknownHostException ex)</code>。<br>对于反射方法的异常，Java7单独引进了一个新的父类：<code>ReflectiveOperationException</code>。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2016/06/24/JAVA8学习（九）/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Nächste Seite</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:www.52brt.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angularjs/">Angularjs</a><small>6</small></li>
  
    <li><a href="/tags/Bootstrap/">Bootstrap</a><small>5</small></li>
  
    <li><a href="/tags/DateTime/">DateTime</a><small>1</small></li>
  
    <li><a href="/tags/HBase/">HBase</a><small>1</small></li>
  
    <li><a href="/tags/JavaFX/">JavaFX</a><small>1</small></li>
  
    <li><a href="/tags/Nashorn/">Nashorn</a><small>1</small></li>
  
    <li><a href="/tags/Nodejs/">Nodejs</a><small>7</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>3</small></li>
  
    <li><a href="/tags/TinkerPop3/">TinkerPop3</a><small>1</small></li>
  
    <li><a href="/tags/ambari/">ambari</a><small>1</small></li>
  
    <li><a href="/tags/centos/">centos</a><small>7</small></li>
  
    <li><a href="/tags/centos6/">centos6</a><small>1</small></li>
  
    <li><a href="/tags/docker/">docker</a><small>3</small></li>
  
    <li><a href="/tags/eclipse/">eclipse</a><small>1</small></li>
  
    <li><a href="/tags/eclipse插件开发/">eclipse插件开发</a><small>1</small></li>
  
    <li><a href="/tags/elasticsearch/">elasticsearch</a><small>6</small></li>
  
    <li><a href="/tags/express/">express</a><small>4</small></li>
  
    <li><a href="/tags/hadoop/">hadoop</a><small>1</small></li>
  
    <li><a href="/tags/hexo/">hexo</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>15</small></li>
  
    <li><a href="/tags/java8/">java8</a><small>9</small></li>
  
    <li><a href="/tags/kafka/">kafka</a><small>1</small></li>
  
    <li><a href="/tags/lambda/">lambda</a><small>2</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>11</small></li>
  
    <li><a href="/tags/markdown/">markdown</a><small>2</small></li>
  
    <li><a href="/tags/maven/">maven</a><small>1</small></li>
  
    <li><a href="/tags/mongodb/">mongodb</a><small>9</small></li>
  
    <li><a href="/tags/mysql/">mysql</a><small>1</small></li>
  
    <li><a href="/tags/nodejs/">nodejs</a><small>1</small></li>
  
    <li><a href="/tags/scala/">scala</a><small>6</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>5</small></li>
  
    <li><a href="/tags/stream/">stream</a><small>2</small></li>
  
    <li><a href="/tags/svg/">svg</a><small>1</small></li>
  
    <li><a href="/tags/titan/">titan</a><small>1</small></li>
  
    <li><a href="/tags/tomcat/">tomcat</a><small>1</small></li>
  
    <li><a href="/tags/其他/">其他</a><small>1</small></li>
  
    <li><a href="/tags/前端/">前端</a><small>17</small></li>
  
    <li><a href="/tags/可视化/">可视化</a><small>1</small></li>
  
    <li><a href="/tags/图数据库/">图数据库</a><small>1</small></li>
  
    <li><a href="/tags/多线程/">多线程</a><small>1</small></li>
  
    <li><a href="/tags/恢复/">恢复</a><small>1</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>9</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 okuc
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>