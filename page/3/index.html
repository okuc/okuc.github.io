<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 3 | 我的后院自留地</title>
  <meta name="author" content="okuc">
  
  <meta name="description" content="hadoop hive hbase cassandra linux elasticsearch eclipse java mysql">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="我的后院自留地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="我的后院自留地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7ea69d6de48b6d7cd2a53bcc519beadc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">我的后院自留地</a></h1>
  <h2><a href="/">琴棋书画诗酒花 当年件件不离它 而今事事都变更 柴米油盐酱醋茶</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="//">首页</a></li>
    
      <li><a href="//archives">归档</a></li>
    
      <li><a href="//coding">编程技术</a></li>
    
      <li><a href="//bigData">大数据技术</a></li>
    
      <li><a href="//dataV">数据可视化</a></li>
    
      <li><a href="//about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-31T14:06:32.000Z"><a href="/2015/12/31/新手学习Express4之四：数据库集成/">2015-12-31</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/31/新手学习Express4之四：数据库集成/">新手学习Express4之四：数据库集成</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="数据库集成"><a href="#数据库集成" class="headerlink" title="数据库集成"></a>数据库集成</h2><ol>
<li><p>为<code>Express</code>应用添加连接数据库的能力，只需要加载相应数据库的<code>Node.js驱动</code>即可。这里会列举一些常用的例子。</p>
<p>除本章列举的例子外，更多的可在npm官网<a href="">https://www.npmjs.com</a>来查找。</p>
</li>
<li><p><code>Cassandra</code>：</p>
<ul>
<li>模块: <code>cassandra-driver</code> (<a href="https://github.com/datastax/nodejs-driver">https://github.com/datastax/nodejs-driver</a>)</li>
<li>安装: <code>$ npm install cassandra-driver</code></li>
<li><p>示例:</p>
<pre><code>var cassandra = require(&apos;cassandra-driver&apos;);
var client = new cassandra.Client({ contactPoints: [&apos;localhost&apos;]});
client.execute(&apos;select key from system.local&apos;, function(err, result) {
if (err) throw err;
console.log(result.rows[0]);
});
</code></pre></li>
</ul>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/31/新手学习Express4之四：数据库集成/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-31T14:06:32.000Z"><a href="/2015/12/31/《Bootstrap用户手册》学习笔记(一)/">2015-12-31</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/31/《Bootstrap用户手册》学习笔记(一)/">《Bootstrap用户手册》学习笔记(一)</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="第1章-Bootstrap提供的网站框架"><a href="#第1章-Bootstrap提供的网站框架" class="headerlink" title="第1章 Bootstrap提供的网站框架"></a>第1章 Bootstrap提供的网站框架</h2><ol>
<li><p><code>Bootstrap</code>中有几种默认样式需要注意，它们专门针对排版和链接。</p>
<ul>
<li>从<code>body</code>中去掉了<code>margin</code>,这样内容就会紧贴浏览器窗口边缘。</li>
<li>为<code>body</code>应用了<code>background-color:white;</code>。</li>
<li><code>Bootstrap</code>以<code>@baseFontFamily</code>、<code>@baseFontSize</code>、<code>@baseLineHeight</code>属性作为排版的基准，确保整个网站的标题及其他内容的行高一致。</li>
<li><p><code>Bootstrap</code>通过<code>@linkColor</code>设置全局链接颜色，只在<code>:hover</code>状态下给链接添加下划线。</p>
<p>要改变默认颜色，可以直接修改相应<code>.less</code>文件中的全局变量值。要么修改<code>scaffolding.less</code>文件，要么修改你自已的样式表。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/31/《Bootstrap用户手册》学习笔记(一)/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-30T14:06:32.000Z"><a href="/2015/12/30/新手学习Express4之三：错误处理、调试Express及使用代理 /">2015-12-30</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/30/新手学习Express4之三：错误处理、调试Express及使用代理 /">新手学习Express4之三：错误处理、调试Express及使用代理</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol>
<li><p>定义错误处理中间件和定义其他中间件一样，除了需要 4 个参数，而不是 3 个，其签名如下 <code>(err, req, res, next)</code> 。</p>
<pre><code>app.use(function(err, req, res, next) {
console.error(err.stack);
res.status(500).send(&apos;Something broke!&apos;);
});
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/30/新手学习Express4之三：错误处理、调试Express及使用代理 /#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-28T14:06:32.000Z"><a href="/2015/12/28/新手学习Express4之二：中间件与模板引擎/">2015-12-28</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/28/新手学习Express4之二：中间件与模板引擎/">新手学习Express4之二：中间件与模板引擎</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ol>
<li><p>中件间是一个可访问请求对象<code>req</code>和响应对象<code>res</code>的函数，在<code>Express</code>应用的请求-响应循环里，下一个内联的中间件通常用变量<code>next</code>表示。</p>
<p>如果当前中间件没有终结请求-响应循环，则必须调用<code>next()</code>方法将控制权交给下一个中间件，否则请求就会挂起。</p>
<p>使用可选择挂载路径，可在应用级别或路由级别装载中间件。</p>
</li>
<li><p><code>Express</code>应用可使用如下几种中间件：</p>
<ul>
<li>应用级中间件</li>
<li>路由级中间件</li>
<li>错误处理中间件</li>
<li>内置中间件</li>
<li>第三方中间件
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/28/新手学习Express4之二：中间件与模板引擎/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-25T14:06:32.000Z"><a href="/2015/12/25/新手学习Express4之一 路由 /">2015-12-25</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/25/新手学习Express4之一 路由 /">新手学习Express4之一:路由</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li><p>路由由一个URI、HTTP请求和若干个句柄组成，它的结构如下：<code>app.METHOD(path,[callback...],callback)</code>。<code>app</code>是<code>express</code>对象的一个实例，<code>METHOD</code>是一个HTTP请求方法，<code>path</code>是服务器上的路径，<code>callback</code>是当路由匹配时要执行的函数。</p>
<p>下面是一个基本的示例：</p>
</li>
</ol>
<pre><code>    var express = require(&apos;express&apos;);
    var app = express();

    //当主页收到GET请求时，返回hello world
    app.get(&apos;/&apos;,function(req,res){
        res.send(&apos;hello world&apos;);
    });


 &lt;!--more--&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
</code></pre><ol>
<li>路由方法是HTTP请求的方法，和<code>express</code>实例相关联。上面的例子就是个<code>GET</code>路由方法，下面一个<code>POST</code>路由方法的例子：</li>
</ol>
<pre><code>    var express = require(&apos;express&apos;);
    var app = express();

    //当主页收到GET请求时，返回hello world
    app.post(&apos;/&apos;,function(req,res){
        res.send(&apos;hello world&apos;);
    });

`express`定义了和HTTP请求对应的如下方法： `get` 、 `post` 、 `put` 、 `head` 、 `delete` 、 `options` 、 `trace` 、 `copy` 、 `lock` 、 `mkcol` 、 `move` 、 `purge` 、 `propfind` 、 `proppatch` 、 `unlock` 、 `report` 、 `mkactivity` 、 `checkout` 、 `merge` 、 `m-search` 、 `notify` 、 `subscribe` 、 `unsubscribe` 、 `patch` 、 `search` 和 `connect`。

有些路由方法名不是合规的JavaScript变量名，此时使用括号记法，比如`app[&apos;m-search&apos;](&apos;/&apos;,function...`

`app.all()`是一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。如下例，只要路径对，任何方法(`GET`、`POST`等)的请求都能执行。

    app.all(&apos;/secret&apos;, function (req, res, next) {
    console.log(&apos;Accessing the secret section ...&apos;);
    next(); // 交给下一个句柄处理
    });
</code></pre><ol>
<li><p>路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。</p>
<p><code>express</code>使用<a href="https://www.npmjs.com/package/path-to-regexp" target="_blank" rel="external">path-to-regex</a>匹配路由路径，具体可查阅文档。 <a href="http://forbeslindesay.github.io/express-route-tester/" target="_blank" rel="external">Express Route Tester</a> 是测试基本 Express 路径的好工具，但不支持模式匹配。</p>
<p>下面是一些例子：</p>
<pre><code>// 匹配根路径的请求
app.get(&apos;/&apos;, function (req, res) {
res.send(&apos;root&apos;);
});
// 匹配 /about 路径的请求
app.get(&apos;/about&apos;, function (req, res) {
res.send(&apos;about&apos;);
});
// 匹配 /random.text 路径的请求
app.get(&apos;/random.text&apos;, function (req, res) {
res.send(&apos;random.text&apos;);
});

//使用字符串模式的路由路径示例：

// 匹配 acd 和 abcd
app.get(&apos;/ab?cd&apos;, function(req, res) {
res.send(&apos;ab?cd&apos;);
});
// 匹配 abcd、abbcd、abbbcd等app.get(&apos;/ab+cd&apos;, function(req, res) {
res.send(&apos;ab+cd&apos;);
});
// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等
app.get(&apos;/ab*cd&apos;, function(req, res) {
res.send(&apos;ab*cd&apos;);
});
// 匹配 /abe 和 /abcde
app.get(&apos;/ab(cd)?e&apos;, function(req, res) {
res.send(&apos;ab(cd)?e&apos;);
});
//字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。

//使用正则表达式的路由路径示例：

// 匹配任何路径中含有 a 的路径：
app.get(/a/, function(req, res) {
res.send(&apos;/a/&apos;);
});
// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等
app.get(/.*fly$/, function(req, res) {
res.send(&apos;/.*fly$/&apos;);
});
</code></pre></li>
<li><p>句柄路由：可以为请求处理多个回调函数，其行为类似中间件()。唯一的区别是这些回调函数有可能调用<code>next(&#39;route&#39;)</code>方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有的路径上继续执行没有意义，则可将控制权交给剩下的路径。</p>
<p>路由路柄有多种形式，可以是一个函数，一个函数数组，或者是两者混合。</p>
<pre><code>//使用一个回调函数处理路由：
app.get(&apos;/example/a&apos;, function (req, res) {
res.send(&apos;Hello from A!&apos;);
});

//使用多个回调函数处理路由（记得指定 next 对象）：
app.get(&apos;/example/b&apos;, function (req, res, next) {
console.log(&apos;response will be sent by the next function ...&apos;);
next();
}, function (req, res) {
res.send(&apos;Hello from B!&apos;);
});

//使用回调函数数组处理路由：
var cb0 = function (req, res, next) {
console.log(&apos;CB0&apos;);
next();
}
var cb1 = function (req, res, next) {
console.log(&apos;CB1&apos;);
next();
}
var cb2 = function (req, res) {
res.send(&apos;Hello from C!&apos;);
}
app.get(&apos;/example/c&apos;, [cb0, cb1, cb2]);

//混合使用函数和函数数组处理路由：
var cb0 = function (req, res, next) {
console.log(&apos;CB0&apos;);
next();
}
var cb1 = function (req, res, next) {
console.log(&apos;CB1&apos;);
next();
}
app.get(&apos;/example/d&apos;, [cb0, cb1], function (req, res, next) {
console.log(&apos;response will be sent by the next function ...&apos;);
next();
}, function (req, res) {
res.send(&apos;Hello from D!&apos;);
});
</code></pre></li>
</ol>
<ol>
<li><p>响应方法</p>
<ul>
<li><code>res.download()</code>： <a href="http://expressjs.com/4x/api.html#res.download" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.download)</a>提示下载文件。</li>
<li><code>res.end()</code>： <a href="http://expressjs.com/4x/api.html#res.end" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.end</a>终结响应。</li>
<li><code>res.json()</code>： <a href="http://expressjs.com/4x/api.html#res.json" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.json</a>发送一个 JSON 响应。</li>
<li><code>res.jsonp()</code>： <a href="http://expressjs.com/4x/api.html#res.jsonp" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.jsonp</a>发送一个支持 JSONP 的 JSON 响应。</li>
<li><code>res.redirect()</code>： <a href="http://expressjs.com/4x/api.html#res.redirect" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.redirect</a>重定向请求。</li>
<li><code>res.render()</code>： <a href="http://expressjs.com/4x/api.html#res.render" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.render</a>渲染视图模板。</li>
<li><code>res.send()</code>： <a href="http://expressjs.com/4x/api.html#res.send" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.send</a>发送各种类型的响应。</li>
<li><code>res.sendFile（）</code>： <a href="http://expressjs.com/4x/api.html#res.sendFile" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.sendFile</a>以八位字节流的形式发送文件。</li>
<li><code>res.sendStatus()</code>： <a href="http://expressjs.com/4x/api.html#res.sendStatus" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.sendStatus</a>设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</li>
</ul>
</li>
<li><p><code>app.route()</code>可用来创建链式路由句柄，它的路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。具体可参考这儿：<a href="http://expressjs.com/4x/api.html#router" target="_blank" rel="external">http://expressjs.com/4x/api.html#router</a>。</p>
<p>下面是一个例子：</p>
</li>
</ol>
<pre><code>app.route(&apos;/book&apos;)
.get(function(req, res) {
res.send(&apos;Get a random book&apos;);
})
.post(function(req, res) {
res.send(&apos;Add a book&apos;);
}).put(function(req, res) {
res.send(&apos;Update the book&apos;);
});
</code></pre><ol>
<li><p><code>express.Router</code>可用来创建模块化、可挂载的路由句柄。<code>Router</code>实例是一个完整的中间件和路由系统，因此常称其为一个<code>mini-app</code>。</p>
<p>下面的实例程序创建了一个路由模块，并加载了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。</p>
<p><code>birds.js</code>源代码：</p>
<pre><code>var express = require(&apos;express&apos;);
var router = express.Router();
// 该路由使用的中间件
router.use(function timeLog(req, res, next) {
console.log(&apos;Time: &apos;, Date.now());
next();
});
// 定义主页路由
router.get(&apos;/&apos;, function(req, res) {
res.send(&apos;Birds home page&apos;);
});
// 定义 about 路由
router.get(&apos;/about&apos;, function(req, res) {
res.send(&apos;About birds&apos;);
});
module.exports = router;
</code></pre></li>
</ol>
<pre><code>在应用中加载路由模块源代码：

    var birds = require(‘./birds’);
     …
     app.use(‘/birds’, birds);

应用即可处理发自`/birds`和`/birds/about`的请求，并且调用为该路由指定的`timeLog`中间件。
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-21T14:06:32.000Z"><a href="/2015/12/21/新手学习mongodb之九：聚合管道/">2015-12-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/21/新手学习mongodb之九：聚合管道/">新手学习mongodb之九：聚合管道</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>聚合操作主要秀于批量数据处理，往往将记录按条件进行分组，然后在每组上分别进行一系列操作，如，求最大最小值、平均值、求和等。</p>
<pre><code>db.orders.aggregate([
{
    $group:{
    _id:&quot;$cust_id&quot;,
    total:{$sum:&quot;$price&quot;}
},{$sort:{total:1}}}])
</code></pre><p>聚合操作能够对记录进行复杂处理，主要用于数理统计和数据挖掘。在MongoDB中，聚合操作的输入是集合中的文档，输出可以是一条或多条文档。</p>
<p>MongoDB提供了强大的聚合功能，针对聚合操作提供了三种方式：</p>
<ul>
<li>聚合管道(Aggregation Pipeline)</li>
<li>单目的聚合操作(Single Purpose Aggregation Operation)</li>
<li>MapReduce编程模型
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/21/新手学习mongodb之九：聚合管道/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-20T14:06:32.000Z"><a href="/2015/12/20/新手学习mongodb之八：GridFS文件存储/">2015-12-20</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/20/新手学习mongodb之八：GridFS文件存储/">新手学习mongodb之：GridFS文件存储</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>文件系统是操作系统用来组织磁盘文件的方法和数据结构，计算机通过文件系统来存储管理数据。</p>
<p>典型的系统有<code>UFS(Unix File System)</code>，<code>EXT(Extended file system)</code>及<code>NTFS(New Technology File System)</code>等。</p>
</li>
<li><p>分布式文件系统，将固定存储于单台机器上的文件系统，扩展到多台机器上，每个节点负责存储部分数据，众多的存储节点组成一个文件系统网络，各个节点之间通过网络进行信和数据传输。</p>
<ul>
<li><code>NFS(Network File System)</code>：相当于<code>RPC Service</code>，使用者可以像使用本地文件系统一样来访问远程的文件。</li>
<li><code>HDFS(Hadoop File System)</code>:采用<code>master/slave</code>架构设计，可以运行于廉价的普通硬件之上，适合超大数据集的应用程序。</li>
<li><code>TFS(Taobao File System)</code>：适合海量非结构化的小文件存储，采用HA架构；文件名可以直接映射到物理地址。</li>
<li><p><code>FastDFS</code>：轻量级的分布式文件系统；采用对等架构设计；可以根据文件ID迅速定位文件。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/20/新手学习mongodb之八：GridFS文件存储/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-19T14:06:32.000Z"><a href="/2015/12/19/新手学习mongodb之七：特殊索引/">2015-12-19</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/19/新手学习mongodb之七：特殊索引/">新手学习mongodb之七：特殊索引</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li>地理空间索引可以对地理位置数据建立索引条目，Mongo原生支持地理位置索引，可以直接用于位置距离计算和查询。MongoDB对原生支持的查询函数在性能上进行了高度的优化，与其它的数据库相比，具有很高的查询效率。MongoDB支持两种类型的地理空间索引：<ul>
<li>球面：<code>2dsphere索引</code></li>
<li>平面：<code>2d索引</code>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/19/新手学习mongodb之七：特殊索引/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-17T14:06:32.000Z"><a href="/2015/12/17/新手学习mongodb之六：普通索引/">2015-12-17</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/17/新手学习mongodb之六：普通索引/">新手学习mongodb之六：普通索引</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>所有的索引信息被保存在<strong>system.indexes</strong>集合中，且默认总是为<code>_id</code>创建索引。<code>db.system.indexes.find()</code>可以查看当前数据库中创建的所有的索引。Mongodb使用的是B-树算法。Mongodb提供的索引类型为：</p>
<ul>
<li>Single Filed:单字段索引，在普通字段、子文档以及子文档的某个字段上建立的索引。</li>
<li>Compound Index:复合索引，同时在多个字段上建立的索引。</li>
<li>Multikey Index:多键索引，对数组建立的索引。</li>
<li>Geospatial Index:地理空间索引，对地理位置数据库建立的索引{支持球面和平面}。</li>
<li>Text Index：全文索引，对每一个词建立索引，支持全文搜索。</li>
<li>Hashed Index：哈希索引，索引中存储的是被索引键的哈希值。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/17/新手学习mongodb之六：普通索引/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-16T14:06:32.000Z"><a href="/2015/12/16/新手学习mongodb之五：游标及模糊查询/">2015-12-16</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/16/新手学习mongodb之五：游标及模糊查询/">新手学习mongodb之五：游标及模糊查询</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li>使用<code>find</code>函数进行查询时，MongoDB并不是一次返回结果集中的所有文档，而是以多条文档的形式分白费来返回查询结果，返回的文档会缓存到内存中。<br>分批的原则是不超过101个文档或1M的数据，以先达到的标准为主。如果101个文档大于1M，则会减少文档的数量，以小的为准，除第一次外，以后每次可以返回4M的文档。<br>这种批量返回结果的好处是，一方面，它可以减少客户端对服务器连接次数，从而减轻服务器的查询负担；另一方面，当查询结果集很大时，批量返回的结果的方式可以减少客户端的等待时间，提高数据的处理效率。<br>在没有建立索引的字段上进行排序，会把符合条件的全部加载到内存中进行排序，所以，一定要建立索引。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/16/新手学习mongodb之五：游标及模糊查询/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/2/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/4/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angularjs/">Angularjs</a><small>6</small></li>
  
    <li><a href="/tags/Bootstrap/">Bootstrap</a><small>5</small></li>
  
    <li><a href="/tags/HBase/">HBase</a><small>1</small></li>
  
    <li><a href="/tags/Nodejs/">Nodejs</a><small>7</small></li>
  
    <li><a href="/tags/TinkerPop3/">TinkerPop3</a><small>1</small></li>
  
    <li><a href="/tags/centos/">centos</a><small>7</small></li>
  
    <li><a href="/tags/centos6/">centos6</a><small>1</small></li>
  
    <li><a href="/tags/docker/">docker</a><small>3</small></li>
  
    <li><a href="/tags/eclipse/">eclipse</a><small>1</small></li>
  
    <li><a href="/tags/eclipse插件开发/">eclipse插件开发</a><small>1</small></li>
  
    <li><a href="/tags/elasticsearch/">elasticsearch</a><small>6</small></li>
  
    <li><a href="/tags/express/">express</a><small>4</small></li>
  
    <li><a href="/tags/hexo/">hexo</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>4</small></li>
  
    <li><a href="/tags/java8/">java8</a><small>3</small></li>
  
    <li><a href="/tags/lambda/">lambda</a><small>2</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>11</small></li>
  
    <li><a href="/tags/markdown/">markdown</a><small>2</small></li>
  
    <li><a href="/tags/maven/">maven</a><small>1</small></li>
  
    <li><a href="/tags/mongodb/">mongodb</a><small>9</small></li>
  
    <li><a href="/tags/mysql/">mysql</a><small>1</small></li>
  
    <li><a href="/tags/nodejs/">nodejs</a><small>1</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>5</small></li>
  
    <li><a href="/tags/stream/">stream</a><small>2</small></li>
  
    <li><a href="/tags/svg/">svg</a><small>1</small></li>
  
    <li><a href="/tags/titan/">titan</a><small>1</small></li>
  
    <li><a href="/tags/tomcat/">tomcat</a><small>1</small></li>
  
    <li><a href="/tags/前端/">前端</a><small>17</small></li>
  
    <li><a href="/tags/可视化/">可视化</a><small>1</small></li>
  
    <li><a href="/tags/图数据库/">图数据库</a><small>1</small></li>
  
    <li><a href="/tags/恢复/">恢复</a><small>1</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>9</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 okuc
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>