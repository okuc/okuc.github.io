<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 5 | 我的后院自留地</title>
  <meta name="author" content="okuc">
  
  <meta name="description" content="hadoop hive hbase cassandra linux elasticsearch eclipse java mysql spark titan tinkpop neo4j">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="我的后院自留地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="我的后院自留地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7ea69d6de48b6d7cd2a53bcc519beadc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">我的后院自留地</a></h1>
  <h2><a href="/">琴棋书画诗酒花 当年件件不离它 而今事事都变更 柴米油盐酱醋茶</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="//">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/coding">编程技术</a></li>
    
      <li><a href="/bigData">大数据技术</a></li>
    
      <li><a href="/dataV">数据可视化</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-31T14:06:32.000Z"><a href="/2015/12/31/新手学习Express4之四：数据库集成/">2015-12-31</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/31/新手学习Express4之四：数据库集成/">新手学习Express4之四：数据库集成</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="数据库集成"><a href="#数据库集成" class="headerlink" title="数据库集成"></a>数据库集成</h2><ol>
<li><p>为<code>Express</code>应用添加连接数据库的能力，只需要加载相应数据库的<code>Node.js驱动</code>即可。这里会列举一些常用的例子。</p>
<p>除本章列举的例子外，更多的可在npm官网<a href="">https://www.npmjs.com</a>来查找。</p>
</li>
<li><p><code>Cassandra</code>：</p>
<ul>
<li>模块: <code>cassandra-driver</code> (<a href="https://github.com/datastax/nodejs-driver">https://github.com/datastax/nodejs-driver</a>)</li>
<li>安装: <code>$ npm install cassandra-driver</code></li>
<li><p>示例:</p>
<pre><code>var cassandra = require(&apos;cassandra-driver&apos;);
var client = new cassandra.Client({ contactPoints: [&apos;localhost&apos;]});
client.execute(&apos;select key from system.local&apos;, function(err, result) {
if (err) throw err;
console.log(result.rows[0]);
});
</code></pre></li>
</ul>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/31/新手学习Express4之四：数据库集成/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-30T14:06:32.000Z"><a href="/2015/12/30/新手学习Express4之三：错误处理、调试Express及使用代理 /">2015-12-30</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/30/新手学习Express4之三：错误处理、调试Express及使用代理 /">新手学习Express4之三：错误处理、调试Express及使用代理</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol>
<li><p>定义错误处理中间件和定义其他中间件一样，除了需要 4 个参数，而不是 3 个，其签名如下 <code>(err, req, res, next)</code> 。</p>
<pre><code>app.use(function(err, req, res, next) {
console.error(err.stack);
res.status(500).send(&apos;Something broke!&apos;);
});
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/30/新手学习Express4之三：错误处理、调试Express及使用代理 /#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-28T14:06:32.000Z"><a href="/2015/12/28/新手学习Express4之二：中间件与模板引擎/">2015-12-28</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/28/新手学习Express4之二：中间件与模板引擎/">新手学习Express4之二：中间件与模板引擎</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><ol>
<li><p>中件间是一个可访问请求对象<code>req</code>和响应对象<code>res</code>的函数，在<code>Express</code>应用的请求-响应循环里，下一个内联的中间件通常用变量<code>next</code>表示。</p>
<p>如果当前中间件没有终结请求-响应循环，则必须调用<code>next()</code>方法将控制权交给下一个中间件，否则请求就会挂起。</p>
<p>使用可选择挂载路径，可在应用级别或路由级别装载中间件。</p>
</li>
<li><p><code>Express</code>应用可使用如下几种中间件：</p>
<ul>
<li>应用级中间件</li>
<li>路由级中间件</li>
<li>错误处理中间件</li>
<li>内置中间件</li>
<li>第三方中间件
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/28/新手学习Express4之二：中间件与模板引擎/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-25T14:06:32.000Z"><a href="/2015/12/25/新手学习Express4之一 路由 /">2015-12-25</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/25/新手学习Express4之一 路由 /">新手学习Express4之一:路由</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li><p>路由由一个URI、HTTP请求和若干个句柄组成，它的结构如下：<code>app.METHOD(path,[callback...],callback)</code>。<code>app</code>是<code>express</code>对象的一个实例，<code>METHOD</code>是一个HTTP请求方法，<code>path</code>是服务器上的路径，<code>callback</code>是当路由匹配时要执行的函数。</p>
<p>下面是一个基本的示例：</p>
</li>
</ol>
<pre><code>    var express = require(&apos;express&apos;);
    var app = express();

    //当主页收到GET请求时，返回hello world
    app.get(&apos;/&apos;,function(req,res){
        res.send(&apos;hello world&apos;);
    });


 &lt;!--more--&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
</code></pre><ol>
<li>路由方法是HTTP请求的方法，和<code>express</code>实例相关联。上面的例子就是个<code>GET</code>路由方法，下面一个<code>POST</code>路由方法的例子：</li>
</ol>
<pre><code>    var express = require(&apos;express&apos;);
    var app = express();

    //当主页收到GET请求时，返回hello world
    app.post(&apos;/&apos;,function(req,res){
        res.send(&apos;hello world&apos;);
    });

`express`定义了和HTTP请求对应的如下方法： `get` 、 `post` 、 `put` 、 `head` 、 `delete` 、 `options` 、 `trace` 、 `copy` 、 `lock` 、 `mkcol` 、 `move` 、 `purge` 、 `propfind` 、 `proppatch` 、 `unlock` 、 `report` 、 `mkactivity` 、 `checkout` 、 `merge` 、 `m-search` 、 `notify` 、 `subscribe` 、 `unsubscribe` 、 `patch` 、 `search` 和 `connect`。

有些路由方法名不是合规的JavaScript变量名，此时使用括号记法，比如`app[&apos;m-search&apos;](&apos;/&apos;,function...`

`app.all()`是一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。如下例，只要路径对，任何方法(`GET`、`POST`等)的请求都能执行。

    app.all(&apos;/secret&apos;, function (req, res, next) {
    console.log(&apos;Accessing the secret section ...&apos;);
    next(); // 交给下一个句柄处理
    });
</code></pre><ol>
<li><p>路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。</p>
<p><code>express</code>使用<a href="https://www.npmjs.com/package/path-to-regexp" target="_blank" rel="external">path-to-regex</a>匹配路由路径，具体可查阅文档。 <a href="http://forbeslindesay.github.io/express-route-tester/" target="_blank" rel="external">Express Route Tester</a> 是测试基本 Express 路径的好工具，但不支持模式匹配。</p>
<p>下面是一些例子：</p>
<pre><code>// 匹配根路径的请求
app.get(&apos;/&apos;, function (req, res) {
res.send(&apos;root&apos;);
});
// 匹配 /about 路径的请求
app.get(&apos;/about&apos;, function (req, res) {
res.send(&apos;about&apos;);
});
// 匹配 /random.text 路径的请求
app.get(&apos;/random.text&apos;, function (req, res) {
res.send(&apos;random.text&apos;);
});

//使用字符串模式的路由路径示例：

// 匹配 acd 和 abcd
app.get(&apos;/ab?cd&apos;, function(req, res) {
res.send(&apos;ab?cd&apos;);
});
// 匹配 abcd、abbcd、abbbcd等app.get(&apos;/ab+cd&apos;, function(req, res) {
res.send(&apos;ab+cd&apos;);
});
// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等
app.get(&apos;/ab*cd&apos;, function(req, res) {
res.send(&apos;ab*cd&apos;);
});
// 匹配 /abe 和 /abcde
app.get(&apos;/ab(cd)?e&apos;, function(req, res) {
res.send(&apos;ab(cd)?e&apos;);
});
//字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。

//使用正则表达式的路由路径示例：

// 匹配任何路径中含有 a 的路径：
app.get(/a/, function(req, res) {
res.send(&apos;/a/&apos;);
});
// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等
app.get(/.*fly$/, function(req, res) {
res.send(&apos;/.*fly$/&apos;);
});
</code></pre></li>
<li><p>句柄路由：可以为请求处理多个回调函数，其行为类似中间件()。唯一的区别是这些回调函数有可能调用<code>next(&#39;route&#39;)</code>方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有的路径上继续执行没有意义，则可将控制权交给剩下的路径。</p>
<p>路由路柄有多种形式，可以是一个函数，一个函数数组，或者是两者混合。</p>
<pre><code>//使用一个回调函数处理路由：
app.get(&apos;/example/a&apos;, function (req, res) {
res.send(&apos;Hello from A!&apos;);
});

//使用多个回调函数处理路由（记得指定 next 对象）：
app.get(&apos;/example/b&apos;, function (req, res, next) {
console.log(&apos;response will be sent by the next function ...&apos;);
next();
}, function (req, res) {
res.send(&apos;Hello from B!&apos;);
});

//使用回调函数数组处理路由：
var cb0 = function (req, res, next) {
console.log(&apos;CB0&apos;);
next();
}
var cb1 = function (req, res, next) {
console.log(&apos;CB1&apos;);
next();
}
var cb2 = function (req, res) {
res.send(&apos;Hello from C!&apos;);
}
app.get(&apos;/example/c&apos;, [cb0, cb1, cb2]);

//混合使用函数和函数数组处理路由：
var cb0 = function (req, res, next) {
console.log(&apos;CB0&apos;);
next();
}
var cb1 = function (req, res, next) {
console.log(&apos;CB1&apos;);
next();
}
app.get(&apos;/example/d&apos;, [cb0, cb1], function (req, res, next) {
console.log(&apos;response will be sent by the next function ...&apos;);
next();
}, function (req, res) {
res.send(&apos;Hello from D!&apos;);
});
</code></pre></li>
</ol>
<ol>
<li><p>响应方法</p>
<ul>
<li><code>res.download()</code>： <a href="http://expressjs.com/4x/api.html#res.download" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.download)</a>提示下载文件。</li>
<li><code>res.end()</code>： <a href="http://expressjs.com/4x/api.html#res.end" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.end</a>终结响应。</li>
<li><code>res.json()</code>： <a href="http://expressjs.com/4x/api.html#res.json" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.json</a>发送一个 JSON 响应。</li>
<li><code>res.jsonp()</code>： <a href="http://expressjs.com/4x/api.html#res.jsonp" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.jsonp</a>发送一个支持 JSONP 的 JSON 响应。</li>
<li><code>res.redirect()</code>： <a href="http://expressjs.com/4x/api.html#res.redirect" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.redirect</a>重定向请求。</li>
<li><code>res.render()</code>： <a href="http://expressjs.com/4x/api.html#res.render" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.render</a>渲染视图模板。</li>
<li><code>res.send()</code>： <a href="http://expressjs.com/4x/api.html#res.send" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.send</a>发送各种类型的响应。</li>
<li><code>res.sendFile（）</code>： <a href="http://expressjs.com/4x/api.html#res.sendFile" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.sendFile</a>以八位字节流的形式发送文件。</li>
<li><code>res.sendStatus()</code>： <a href="http://expressjs.com/4x/api.html#res.sendStatus" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.sendStatus</a>设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</li>
</ul>
</li>
<li><p><code>app.route()</code>可用来创建链式路由句柄，它的路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。具体可参考这儿：<a href="http://expressjs.com/4x/api.html#router" target="_blank" rel="external">http://expressjs.com/4x/api.html#router</a>。</p>
<p>下面是一个例子：</p>
</li>
</ol>
<pre><code>app.route(&apos;/book&apos;)
.get(function(req, res) {
res.send(&apos;Get a random book&apos;);
})
.post(function(req, res) {
res.send(&apos;Add a book&apos;);
}).put(function(req, res) {
res.send(&apos;Update the book&apos;);
});
</code></pre><ol>
<li><p><code>express.Router</code>可用来创建模块化、可挂载的路由句柄。<code>Router</code>实例是一个完整的中间件和路由系统，因此常称其为一个<code>mini-app</code>。</p>
<p>下面的实例程序创建了一个路由模块，并加载了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。</p>
<p><code>birds.js</code>源代码：</p>
<pre><code>var express = require(&apos;express&apos;);
var router = express.Router();
// 该路由使用的中间件
router.use(function timeLog(req, res, next) {
console.log(&apos;Time: &apos;, Date.now());
next();
});
// 定义主页路由
router.get(&apos;/&apos;, function(req, res) {
res.send(&apos;Birds home page&apos;);
});
// 定义 about 路由
router.get(&apos;/about&apos;, function(req, res) {
res.send(&apos;About birds&apos;);
});
module.exports = router;
</code></pre></li>
</ol>
<pre><code>在应用中加载路由模块源代码：

    var birds = require(‘./birds’);
     …
     app.use(‘/birds’, birds);

应用即可处理发自`/birds`和`/birds/about`的请求，并且调用为该路由指定的`timeLog`中间件。
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-21T14:06:32.000Z"><a href="/2015/12/21/新手学习mongodb之九：聚合管道/">2015-12-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/21/新手学习mongodb之九：聚合管道/">新手学习mongodb之九：聚合管道</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>聚合操作主要秀于批量数据处理，往往将记录按条件进行分组，然后在每组上分别进行一系列操作，如，求最大最小值、平均值、求和等。</p>
<pre><code>db.orders.aggregate([
{
    $group:{
    _id:&quot;$cust_id&quot;,
    total:{$sum:&quot;$price&quot;}
},{$sort:{total:1}}}])
</code></pre><p>聚合操作能够对记录进行复杂处理，主要用于数理统计和数据挖掘。在MongoDB中，聚合操作的输入是集合中的文档，输出可以是一条或多条文档。</p>
<p>MongoDB提供了强大的聚合功能，针对聚合操作提供了三种方式：</p>
<ul>
<li>聚合管道(Aggregation Pipeline)</li>
<li>单目的聚合操作(Single Purpose Aggregation Operation)</li>
<li>MapReduce编程模型
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/21/新手学习mongodb之九：聚合管道/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-20T14:06:32.000Z"><a href="/2015/12/20/新手学习mongodb之八：GridFS文件存储/">2015-12-20</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/20/新手学习mongodb之八：GridFS文件存储/">新手学习mongodb之：GridFS文件存储</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>文件系统是操作系统用来组织磁盘文件的方法和数据结构，计算机通过文件系统来存储管理数据。</p>
<p>典型的系统有<code>UFS(Unix File System)</code>，<code>EXT(Extended file system)</code>及<code>NTFS(New Technology File System)</code>等。</p>
</li>
<li><p>分布式文件系统，将固定存储于单台机器上的文件系统，扩展到多台机器上，每个节点负责存储部分数据，众多的存储节点组成一个文件系统网络，各个节点之间通过网络进行信和数据传输。</p>
<ul>
<li><code>NFS(Network File System)</code>：相当于<code>RPC Service</code>，使用者可以像使用本地文件系统一样来访问远程的文件。</li>
<li><code>HDFS(Hadoop File System)</code>:采用<code>master/slave</code>架构设计，可以运行于廉价的普通硬件之上，适合超大数据集的应用程序。</li>
<li><code>TFS(Taobao File System)</code>：适合海量非结构化的小文件存储，采用HA架构；文件名可以直接映射到物理地址。</li>
<li><p><code>FastDFS</code>：轻量级的分布式文件系统；采用对等架构设计；可以根据文件ID迅速定位文件。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/20/新手学习mongodb之八：GridFS文件存储/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-19T14:06:32.000Z"><a href="/2015/12/19/新手学习mongodb之七：特殊索引/">2015-12-19</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/19/新手学习mongodb之七：特殊索引/">新手学习mongodb之七：特殊索引</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li>地理空间索引可以对地理位置数据建立索引条目，Mongo原生支持地理位置索引，可以直接用于位置距离计算和查询。MongoDB对原生支持的查询函数在性能上进行了高度的优化，与其它的数据库相比，具有很高的查询效率。MongoDB支持两种类型的地理空间索引：<ul>
<li>球面：<code>2dsphere索引</code></li>
<li>平面：<code>2d索引</code>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/19/新手学习mongodb之七：特殊索引/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-17T14:06:32.000Z"><a href="/2015/12/17/新手学习mongodb之六：普通索引/">2015-12-17</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/17/新手学习mongodb之六：普通索引/">新手学习mongodb之六：普通索引</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>所有的索引信息被保存在<strong>system.indexes</strong>集合中，且默认总是为<code>_id</code>创建索引。<code>db.system.indexes.find()</code>可以查看当前数据库中创建的所有的索引。Mongodb使用的是B-树算法。Mongodb提供的索引类型为：</p>
<ul>
<li>Single Filed:单字段索引，在普通字段、子文档以及子文档的某个字段上建立的索引。</li>
<li>Compound Index:复合索引，同时在多个字段上建立的索引。</li>
<li>Multikey Index:多键索引，对数组建立的索引。</li>
<li>Geospatial Index:地理空间索引，对地理位置数据库建立的索引{支持球面和平面}。</li>
<li>Text Index：全文索引，对每一个词建立索引，支持全文搜索。</li>
<li>Hashed Index：哈希索引，索引中存储的是被索引键的哈希值。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/17/新手学习mongodb之六：普通索引/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-16T14:06:32.000Z"><a href="/2015/12/16/新手学习mongodb之五：游标及模糊查询/">2015-12-16</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/16/新手学习mongodb之五：游标及模糊查询/">新手学习mongodb之五：游标及模糊查询</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li>使用<code>find</code>函数进行查询时，MongoDB并不是一次返回结果集中的所有文档，而是以多条文档的形式分白费来返回查询结果，返回的文档会缓存到内存中。<br>分批的原则是不超过101个文档或1M的数据，以先达到的标准为主。如果101个文档大于1M，则会减少文档的数量，以小的为准，除第一次外，以后每次可以返回4M的文档。<br>这种批量返回结果的好处是，一方面，它可以减少客户端对服务器连接次数，从而减轻服务器的查询负担；另一方面，当查询结果集很大时，批量返回的结果的方式可以减少客户端的等待时间，提高数据的处理效率。<br>在没有建立索引的字段上进行排序，会把符合条件的全部加载到内存中进行排序，所以，一定要建立索引。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/16/新手学习mongodb之五：游标及模糊查询/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-15T14:06:32.000Z"><a href="/2015/12/15/新手学习mongodb之四：使用find轻松查询数据/">2015-12-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/15/新手学习mongodb之四：使用find轻松查询数据/">新手学习mongodb之四：使用find轻松查询数据</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>find参数的原型如下：<code>db.集合名.find(query,fields,limit,skip)</code>,这四个参数的意思如下：</p>
<ul>
<li><code>query</code>：指明查询条件，相当于SQL中的where语句，例如：<code>db.std.find({name:&quot;henry&quot;,&quot;ang&quot;:{$lt:22}})</code></li>
<li><code>fields</code>:用于字段映射，语法格式:<code>{field:0}</code>或<code>{filed:1}</code>用来表示该字段在结果中是否显示。<code>1</code>为显示。如：<code>db.std.find({&quot;age&quot;:{$lt:22}},{&quot;_id&quot;:0,&quot;name&quot;:1})</code>,除<code>_id</code>字段，其它字段必须设置同样的值，要么为<code>0</code>，要么为<code>1</code>。如果<code>_id</code>为<code>1</code>，那么其他字段必须为<code>1</code>；如果<code>_id</code>字段为<code>0</code>，其他字段可同时为<code>0或1</code>。</li>
<li>limit:限制查询结果集的文档数量，指定查询返回结果数量的上限，例如：<code>db.std.find({name:&quot;henry&quot;},{&quot;name&quot;:1,&quot;age&quot;:1},5)</code></li>
<li>skip：跳过一定数据量的结果，设置第一条返回文档的偏移量。如<code>db.std.find({name:&quot;henry&quot;},{&quot;name&quot;:1,&quot;age&quot;:1},5,20)</code></li>
<li><p>返回对象为cursor对象<code>var cursor = db.std.find({name:&quot;joe&quot;})</code></p>
<p><a id="more"></a></p>
<p>使用find函数时需要注意以下问题：</p>
</li>
<li><p>一次只能查询一个集合，不能针对多个集合</p>
</li>
<li><p><code>find</code>参数为空或者查询条件为空查询时，会返回集合中的所有文档。<code>db.std.find()</code>或<code>db.std.find()</code></p>
</li>
<li>除了将<code>limit</code>和<code>skip</code>作为<code>find</code>函数的参数外，还可以单独使用<code>limit</code>和<code>skip</code>函数来修饰查询结果。<code>db.std.find({age:{$lt:22}}).limit(5).skip(10)</code></li>
<li>返回的查询结果默认情况下是无序的，如果需要对结果进行排序，可以使用sort函数。例如：db.std.find().sort({name:1,age:-1})</li>
<li>db.collection.findOne()只会返回第一条数据</li>
<li>当查询的集合文档数量很大时，为了加快数据的查询速度可以创建索引</li>
<li><p>除了使用find函数实现基本查询外，还可以使用聚合框架，用于复杂查询。</p>
<pre><code>dbService = connect(&quot;localhost:27017&quot;);
db = dbService.getSiblingDB(&quot;okuc&quot;);
db.query_test.drop();
var bulk = db.query_test.initializeUnorderedBulkOp();
var doc1 = {
            name:&quot;joe&quot;,
            age:20
}
bulk.insert(doc1);
var doc2 = {
            name:&quot;joe&quot;,
            age:31
}
bulk.insert(doc2);
var doc3 = {
            name:&quot;henry&quot;,
            age:21
}
bulk.insert(doc3);
var doc4 = {
            name:&quot;john&quot;,
            age:null
}
bulk.insert(doc4);

bulk.execute()

var cursor = db.query_test.find(
        {},//查询条件
        {_id:0,age:1},//字段映射
        2,//返回结果条数
        1).sort({age:1});//跳过文档条件 结果按照年龄升序排列
);
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {},//查询条件
        {_id:0,age:1}).limit(2).skip(1).sort({age:1});
);
printjson(cursor.toArray())
</code></pre></li>
</ul>
</li>
<li><p>比较查询操作符共有以下几种：</p>
<ul>
<li><code>$wq / $ne</code>:等于/不等于<code>{&lt;field&gt;:{$eq:&lt;value&gt;}}</code></li>
<li><code>$gt / $gte</code>:大于/大于等于<code>{&lt;field&gt;:{$gt:&lt;value&gt;}}</code></li>
<li><code>$lt / $lte</code>:小于/小于等于<code>{&lt;field&gt;:{$lt:&lt;value&gt;}}</code></li>
<li><code>$in / $nin</code>：包含/不包含<code>{&lt;field&gt;:{$in:[&lt;value1&gt;,&lt;value2&gt;...&lt;valueN&gt;]}}</code></li>
</ul>
</li>
<li><p>利用逻辑查询操作符还可以连接多个查询条件</p>
<ul>
<li><code>$and</code>:与<code>{$and:[{&lt;expression1&gt;},&lt;expression2&gt;},...,&lt;expressionN&gt;}]}</code></li>
<li><code>$or</code>：或<code>{$or:[{&lt;expression1&gt;},&lt;expression2&gt;},...,&lt;expressionN&gt;}]}</code></li>
<li><code>$nor</code>:非<code>{$nor:[{&lt;expression1&gt;},&lt;expression2&gt;},...,&lt;expressionN&gt;}]}</code></li>
<li><code>$not</code>：取反<code>{$not:[{&lt;expression1&gt;},&lt;expression2&gt;},...,&lt;expressionN&gt;}]}</code></li>
</ul>
</li>
<li><p>元素查询操作符</p>
<ul>
<li><code>$exists</code>:按照字段是否存在来查询文档<code>{field:{$exists:&lt;boolean&gt;}}</code></li>
<li><p><code>$type</code>:选择字段值为指定BSON数据类型编号的文档<code>{field:{$type:&lt;BSON type&gt;}}</code></p>
<pre><code>dbService = connect(&quot;localhost:27017&quot;);
db = dbService.getSiblingDB(&quot;okuc&quot;);
db.query_test.drop();
var bulk = db.query_test.initializeUnorderedBulkOp();
var doc1 = {
            name:&quot;joe&quot;,
            age:20
}
bulk.insert(doc1);
var doc2 = {
            name:&quot;joe&quot;,
            age:31
}
bulk.insert(doc2);
var doc3 = {
            name:&quot;henry&quot;,
            age:21
}
bulk.insert(doc3);
var doc4 = {
            name:&quot;john&quot;,
            age:null
}
bulk.insert(doc4);

bulk.execute()

var cursor = db.query_test.find(
        {
    age:{$eq:20}//也可以写成 age:20
    //age:20
    }
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {
        {
    age:{$nin:[20,21]}//键值等于20,21的文档
    //age:20
    }
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {//查询年龄等于19或21且名字等于joe或jack的数据
    $and:[{ $or:[{age:19},age:21]},
          { $or:[{name:&quot;joe&quot;},{name:&quot;jack&quot;}]}
    ]
    //age:20
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {
    $nor:[{name:&quot;joe&quot;},{name:&quot;jack&quot;}]//查出姓名不等于joe或jack的人
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {
    age:{$not:{$gt:22,$lte30}}年龄小于等于22，且大于30
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {
    age:{$exists:true}//存在年龄的人
});
printjson(cursor.toArray())
</code></pre></li>
</ul>
</li>
<li><p>查询操作符介绍及使用–<code>$where</code>查询</p>
<p><code>$where</code>可以将JavaScript表达式的字符串或JavaScript函数作为查询语句的一部分，在JavaScript表达式和函数中，可以使用this或obj来引用当前操作的文档。<code>db.collection.find({$where:&quot;this.credits == this.debits&quot;})</code>,只有js或函数返回值为true时，才会返回当前文档。</p>
<p>查询时，<code>$where</code>操作符不能使用索引，每个文档需要从BSON对象转换成JS对象后，才可以通过<code>$where</code>表达式来运行。所以，比一般查询要慢，因此要避免使用。</p>
<pre><code>dbService = connect(&quot;localhost:27017&quot;);
db = dbService.getSiblingDB(&quot;okuc&quot;);
db.query_test.drop();
var bulk = db.query_test.initializeUnorderedBulkOp();
var doc1 = {
            &quot;apple&quot;:1,&quot;banana&quot;:6,&quot;peach&quot;:4
}
bulk.insert(doc1);
var doc2 = {
            &quot;apple&quot;:3,&quot;banana&quot;:3,&quot;peach&quot;:4
}
bulk.insert(doc2);

bulk.execute()

var cursor = db.query_test.find(
        {
     $where:function(){
        for(var current in this){
            for(var other in this){
                if(current !=other &amp;&amp; this[current]==this[other]) return true;
            }
        }
    }
    }
});
printjson(cursor.toArray());
        var cursor = db.query_test.find(
        {
     $where:&quot;this.apple==1 &amp;&amp; this.banana==6&quot;
});
printjson(cursor.toArray());
</code></pre></li>
<li><p>内嵌文档查询包括两种情况</p>
<p>如果是查询整个文档，当内嵌文档键值对的数量以及键值对的顺序都相同时，才会匹配；如果是查询某个字段，需要使用点操作符。</p>
<pre><code>dbService = connect(&quot;localhost:27017&quot;);
db = dbService.getSiblingDB(&quot;okuc&quot;);
db.query_test.drop();
var bulk = db.query_test.initializeUnorderedBulkOp();
var doc1 = {
            &quot;name&quot;:&quot;xiaoli&quot;,&quot;age&quot;:20,&quot;address&quot;:
{&quot;province&quot;:&quot;GuangDong&quot;,&quot;city&quot;:ShenZhen}
}
bulk.insert(doc1);
var doc2 = {
            &quot;name&quot;:&quot;xiaoqing&quot;,&quot;age&quot;:22,&quot;address&quot;:
{&quot;city&quot;:ShenZhen,&quot;province&quot;:&quot;GuangDong&quot;}
}
bulk.insert(doc2);

bulk.execute()

var cursor = db.query_embedded.fin({
    &quot;address&quot;:{
        &quot;province&quot;:&quot;GuangDong&quot;
    }
});
printjson(cursor.toArray());
</code></pre></li>
<li><p>数组查询</p>
<ul>
<li><code>$all</code>:查询包含参数数组中所有元素的文档</li>
<li><code>$elemMatch</code>:多条件查询</li>
<li><code>$size</code>：查询指定长度的数组</li>
<li>`&lt;div class=”entry”:返回第一个匹配的数组元素</li>
<li><code>$elemMatch</code>：按条件返回数组元素的子集</li>
<li><p><code>$slice</code>：返回连续数组元素的子集</p>
<pre><code>dbService = connect(&quot;localhost:27017&quot;);
db = dbService.getSiblingDB(&quot;okuc&quot;);
db.query_test.drop();
var bulk = db.query_test.initializeUnorderedBulkOp();
var doc1 = {_id:5,
            name:&quot;xiaoli&quot;,
            age:20,
            scores:[95,98,99]
}
bulk.insert(doc1);
var doc2 = {_id:6,
            name:&quot;xiaoqiang&quot;,
            age:22,
            scores:[95,99]
}
bulk.insert(doc2);
var doc3 = {_id:7,
            name:&quot;xiaoming&quot;,
            age:22,
            scores:[99,95,98]
}
bulk.insert(doc3);                
bulk.execute()

var cursor = db.query_array.find(//整个数组查询
    {
        scores:[95,98,99]
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//整个数组查询
    {
        scores:[95,98,99]
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询数组包括95的元素
    {
        scores:95
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询数组第一个元素是95的元素
    {
        scores.0:95
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询数组包括99,98两个元素的文档，顺序可以不同
    {
        scores:{
            $all:[99,98]
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询scores数组中有一个元素大于等于95，且小于等于99的元素
    {
        scores:{
            $elemMatch:{$gt:95,$lt:99}
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询scores数组中有一个元素大于等于95，还有一个元素小于等于99的数组
    {
        scores:{
            $gt:95,$lt:99
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//只显示大于等于95且小于等于99的元素
    { {},//查询条件
        {scores:{//查询映射
            $elemMatch:{$gt:95,$lt:99}
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询指定长度的数组
    { 
        {scores:{
            $size:2
        }}
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//显示时跳过第一个元素，最多只显示两个元素
    { {},//查询条件
        {scores:{//查询映射
            $slice:[1,2]
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询数组中分数大于等于94的数组元素
    { {scores：{$gt:94}},//查询条件
        { &quot;scores.$&quot;:1;//只显示第一个元素。这个映射必须出现在查询条件中
        }
    }
);
printjson(cursor.toArray());

dbService = connect(&quot;localhost:27017&quot;);
db = dbService.getSiblingDB(&quot;okuc&quot;);
db.query_test.drop();
var bulk = db.query_test.initializeUnorderedBulkOp();
var doc1 = {_id:1,
            name:&quot;xiaoli&quot;,
            age:20,
            scores:[{课程：&quot;语文&quot;，成绩：90},{课程：&quot;数学&quot;，成绩：95}]
}
bulk.insert(doc1);
var doc2 = {id:1,
            name:&quot;xiaoqiang&quot;,
            age:22,
            scores:[{课程：&quot;语文&quot;，成绩：92},{课程：&quot;英语&quot;，成绩：90}]
}
bulk.insert(doc2);

bulk.execute()

var cursor = db.array_embedded.find({&apos;scores.成绩&apos;：90});//不使用数组索引，查询数组中成绩为90的元素
printjson(cursor.toArray());

var cursor = db.array_embedded.find({&apos;scores.1.成绩&apos;：90});//使用数组索引，查询数组第二个元素中成绩为90的元素
printjson(cursor.toArray());

var cursor = db.array_embedded.find({&apos;scores:{$elemMatch:{&quot;课程&quot;:&quot;语文&quot;,&quot;成绩&quot;：90}}});//查询数组中包含课程为语文，成绩为90的文档
printjson(cursor.toArray());
</code></pre></li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/page/4/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/6/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:www.52brt.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angularjs/">Angularjs</a><small>6</small></li>
  
    <li><a href="/tags/Bootstrap/">Bootstrap</a><small>5</small></li>
  
    <li><a href="/tags/DateTime/">DateTime</a><small>1</small></li>
  
    <li><a href="/tags/HBase/">HBase</a><small>1</small></li>
  
    <li><a href="/tags/JavaFX/">JavaFX</a><small>1</small></li>
  
    <li><a href="/tags/Nashorn/">Nashorn</a><small>1</small></li>
  
    <li><a href="/tags/Nodejs/">Nodejs</a><small>7</small></li>
  
    <li><a href="/tags/Scala/">Scala</a><small>3</small></li>
  
    <li><a href="/tags/TinkerPop3/">TinkerPop3</a><small>1</small></li>
  
    <li><a href="/tags/ambari/">ambari</a><small>1</small></li>
  
    <li><a href="/tags/centos/">centos</a><small>7</small></li>
  
    <li><a href="/tags/centos6/">centos6</a><small>1</small></li>
  
    <li><a href="/tags/docker/">docker</a><small>3</small></li>
  
    <li><a href="/tags/eclipse/">eclipse</a><small>1</small></li>
  
    <li><a href="/tags/eclipse插件开发/">eclipse插件开发</a><small>1</small></li>
  
    <li><a href="/tags/elasticsearch/">elasticsearch</a><small>6</small></li>
  
    <li><a href="/tags/express/">express</a><small>4</small></li>
  
    <li><a href="/tags/hadoop/">hadoop</a><small>1</small></li>
  
    <li><a href="/tags/hexo/">hexo</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>15</small></li>
  
    <li><a href="/tags/java8/">java8</a><small>9</small></li>
  
    <li><a href="/tags/kafka/">kafka</a><small>1</small></li>
  
    <li><a href="/tags/lambda/">lambda</a><small>2</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>11</small></li>
  
    <li><a href="/tags/markdown/">markdown</a><small>2</small></li>
  
    <li><a href="/tags/maven/">maven</a><small>1</small></li>
  
    <li><a href="/tags/mongodb/">mongodb</a><small>9</small></li>
  
    <li><a href="/tags/mysql/">mysql</a><small>1</small></li>
  
    <li><a href="/tags/nodejs/">nodejs</a><small>1</small></li>
  
    <li><a href="/tags/scala/">scala</a><small>7</small></li>
  
    <li><a href="/tags/shell/">shell</a><small>5</small></li>
  
    <li><a href="/tags/stream/">stream</a><small>2</small></li>
  
    <li><a href="/tags/svg/">svg</a><small>1</small></li>
  
    <li><a href="/tags/titan/">titan</a><small>1</small></li>
  
    <li><a href="/tags/tomcat/">tomcat</a><small>1</small></li>
  
    <li><a href="/tags/其他/">其他</a><small>1</small></li>
  
    <li><a href="/tags/前端/">前端</a><small>17</small></li>
  
    <li><a href="/tags/可视化/">可视化</a><small>1</small></li>
  
    <li><a href="/tags/图数据库/">图数据库</a><small>1</small></li>
  
    <li><a href="/tags/多线程/">多线程</a><small>1</small></li>
  
    <li><a href="/tags/恢复/">恢复</a><small>1</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>9</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 okuc
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>