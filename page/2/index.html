<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 2 | 我的后院自留地</title>
  <meta name="author" content="okuc">
  
  <meta name="description" content="hadoop hive hbase cassandra linux elasticsearch eclipse java mysql">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="我的后院自留地"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="我的后院自留地" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


<script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?7ea69d6de48b6d7cd2a53bcc519beadc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">我的后院自留地</a></h1>
  <h2><a href="/">琴棋书画诗酒花 当年件件不离它 而今事事都变更 柴米油盐酱醋茶</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/coding">编程技术</a></li>
    
      <li><a href="/bigData">大数据技术</a></li>
    
      <li><a href="/dataV">数据可视化</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-31T14:06:32.000Z"><a href="/2015/12/31/新手学习Express4之四：数据库集成/">2015-12-31</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/31/新手学习Express4之四：数据库集成/">新手学习Express4之四：数据库集成</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="数据库集成">数据库集成</h2><ol>
<li><p>为<code>Express</code>应用添加连接数据库的能力，只需要加载相应数据库的<code>Node.js驱动</code>即可。这里会列举一些常用的例子。</p>
<p>除本章列举的例子外，更多的可在npm官网<a href="">https://www.npmjs.com</a>来查找。</p>
</li>
<li><p><code>Cassandra</code>：</p>
<ul>
<li>模块: <code>cassandra-driver</code> (<a href="https://github.com/datastax/nodejs-driver">https://github.com/datastax/nodejs-driver</a>)</li>
<li>安装: <code>$ npm install cassandra-driver</code></li>
<li><p>示例:</p>
<pre><code><span class="keyword">var</span> cassandra = require('cassandra-driver');
<span class="keyword">var</span> client = new cassandra.<span class="type">Client</span>({ contactPoints: ['localhost']});
client.execute('select key <span class="keyword">from</span> system.local', function(err, <span class="literal">result</span>) {
<span class="keyword">if</span> (err) throw err;
console.log(<span class="literal">result</span>.rows[<span class="number">0</span>]);
});
</code></pre></li>
</ul>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/31/新手学习Express4之四：数据库集成/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-30T14:06:32.000Z"><a href="/2015/12/30/新手学习Express4之三：错误处理、调试Express及使用代理 /">2015-12-30</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/30/新手学习Express4之三：错误处理、调试Express及使用代理 /">新手学习Express4之三：错误处理、调试Express及使用代理</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="错误处理">错误处理</h2><ol>
<li><p>定义错误处理中间件和定义其他中间件一样，除了需要 4 个参数，而不是 3 个，其签名如下 <code>(err, req, res, next)</code> 。</p>
<pre><code><span class="keyword">app</span>.<span class="keyword">use</span>(function(<span class="keyword">err</span>, req, res, next) {
console.<span class="keyword">error</span>(<span class="keyword">err</span>.<span class="keyword">stack</span>);
res.status(500).send('Something broke!');
});
</code></pre>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/30/新手学习Express4之三：错误处理、调试Express及使用代理 /#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-28T14:06:32.000Z"><a href="/2015/12/28/新手学习Express4之二：中间件与模板引擎/">2015-12-28</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/28/新手学习Express4之二：中间件与模板引擎/">新手学习Express4之二：中间件与模板引擎</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="中间件">中间件</h2><ol>
<li><p>中件间是一个可访问请求对象<code>req</code>和响应对象<code>res</code>的函数，在<code>Express</code>应用的请求-响应循环里，下一个内联的中间件通常用变量<code>next</code>表示。</p>
<p>如果当前中间件没有终结请求-响应循环，则必须调用<code>next()</code>方法将控制权交给下一个中间件，否则请求就会挂起。</p>
<p>使用可选择挂载路径，可在应用级别或路由级别装载中间件。</p>
</li>
<li><p><code>Express</code>应用可使用如下几种中间件：</p>
<ul>
<li>应用级中间件</li>
<li>路由级中间件</li>
<li>错误处理中间件</li>
<li>内置中间件</li>
<li>第三方中间件
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/28/新手学习Express4之二：中间件与模板引擎/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-25T14:06:32.000Z"><a href="/2015/12/25/新手学习Express4之一 路由 /">2015-12-25</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/25/新手学习Express4之一 路由 /">新手学习Express4之一:路由</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="路由">路由</h2><ol>
<li><p>路由由一个URI、HTTP请求和若干个句柄组成，它的结构如下：<code>app.METHOD(path,[callback...],callback)</code>。<code>app</code>是<code>express</code>对象的一个实例，<code>METHOD</code>是一个HTTP请求方法，<code>path</code>是服务器上的路径，<code>callback</code>是当路由匹配时要执行的函数。</p>
<p>下面是一个基本的示例：</p>
</li>
</ol>
<pre><code>    var express = require('express');
    var app = express();

    //当主页收到GET请求时，返回hello world
    app.get('/',function(req,res){
        res.send('hello world');
    });


 <span class="comment">&lt;!--more--&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">id</span>=<span class="value">"more"</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span>
</code></pre><ol>
<li>路由方法是HTTP请求的方法，和<code>express</code>实例相关联。上面的例子就是个<code>GET</code>路由方法，下面一个<code>POST</code>路由方法的例子：</li>
</ol>
<pre><code>    var express = require('express')<span class="comment">;</span>
    var app = express()<span class="comment">;</span>

    //当主页收到GET请求时，返回hello world
    app.post('/',function(req,res){
        res.send('hello world')<span class="comment">;</span>
    })<span class="comment">;</span>

<span class="escape">`e</span>xpress<span class="escape">`定</span>义了和HTTP请求对应的如下方法： <span class="escape">`g</span>et<span class="escape">` </span>、 <span class="escape">`p</span>ost<span class="escape">` </span>、 <span class="escape">`p</span>ut<span class="escape">` </span>、 <span class="escape">`h</span>ead<span class="escape">` </span>、 <span class="escape">`d</span>elete<span class="escape">` </span>、 <span class="escape">`o</span>ptions<span class="escape">` </span>、 <span class="escape">`t</span>race<span class="escape">` </span>、 <span class="escape">`c</span>opy<span class="escape">` </span>、 <span class="escape">`l</span>ock<span class="escape">` </span>、 <span class="escape">`m</span>kcol<span class="escape">` </span>、 <span class="escape">`m</span>ove<span class="escape">` </span>、 <span class="escape">`p</span>urge<span class="escape">` </span>、 <span class="escape">`p</span>ropfind<span class="escape">` </span>、 <span class="escape">`p</span>roppatch<span class="escape">` </span>、 <span class="escape">`u</span>nlock<span class="escape">` </span>、 <span class="escape">`r</span>eport<span class="escape">` </span>、 <span class="escape">`m</span>kactivity<span class="escape">` </span>、 <span class="escape">`c</span>heckout<span class="escape">` </span>、 <span class="escape">`m</span>erge<span class="escape">` </span>、 <span class="escape">`m</span>-search<span class="escape">` </span>、 <span class="escape">`n</span>otify<span class="escape">` </span>、 <span class="escape">`s</span>ubscribe<span class="escape">` </span>、 <span class="escape">`u</span>nsubscribe<span class="escape">` </span>、 <span class="escape">`p</span>atch<span class="escape">` </span>、 <span class="escape">`s</span>earch<span class="escape">` </span>和 <span class="escape">`c</span>onnect<span class="escape">`。</span>

有些路由方法名不是合规的JavaScript变量名，此时使用括号记法，比如<span class="escape">`a</span>pp['m-search']('/',function...<span class="escape">`
</span>
<span class="escape">`a</span>pp.all()<span class="escape">`是</span>一个特殊的路由方法，没有任何HTTP方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。如下例，只要路径对，任何方法(<span class="escape">`G</span>ET<span class="escape">`、</span><span class="escape">`P</span>OST<span class="escape">`等</span>)的请求都能执行。

    app.all('/secret', function (req, res, next) {
    console.log('Accessing the secret section ...')<span class="comment">;</span>
    next()<span class="comment">; // 交给下一个句柄处理</span>
    })<span class="comment">;</span>
</code></pre><ol>
<li><p>路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。</p>
<p><code>express</code>使用<a href="https://www.npmjs.com/package/path-to-regexp" target="_blank" rel="external">path-to-regex</a>匹配路由路径，具体可查阅文档。 <a href="http://forbeslindesay.github.io/express-route-tester/" target="_blank" rel="external">Express Route Tester</a> 是测试基本 Express 路径的好工具，但不支持模式匹配。</p>
<p>下面是一些例子：</p>
<pre><code><span class="comment">// 匹配根路径的请求</span>
app.<span class="keyword">get</span>(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
res.send(<span class="string">'root'</span>);
});
<span class="comment">// 匹配 /about 路径的请求</span>
app.<span class="keyword">get</span>(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
res.send(<span class="string">'about'</span>);
});
<span class="comment">// 匹配 /random.text 路径的请求</span>
app.<span class="keyword">get</span>(<span class="string">'/random.text'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res)</span> </span>{
res.send(<span class="string">'random.text'</span>);
});

<span class="comment">//使用字符串模式的路由路径示例：</span>

<span class="comment">// 匹配 acd 和 abcd</span>
app.<span class="keyword">get</span>(<span class="string">'/ab?cd'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
res.send(<span class="string">'ab?cd'</span>);
});
<span class="comment">// 匹配 abcd、abbcd、abbbcd等app.get('/ab+cd', function(req, res) {</span>
res.send(<span class="string">'ab+cd'</span>);
});
<span class="comment">// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等</span>
app.<span class="keyword">get</span>(<span class="string">'/ab*cd'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
res.send(<span class="string">'ab*cd'</span>);
});
<span class="comment">// 匹配 /abe 和 /abcde</span>
app.<span class="keyword">get</span>(<span class="string">'/ab(cd)?e'</span>, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
res.send(<span class="string">'ab(cd)?e'</span>);
});
<span class="comment">//字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。</span>

<span class="comment">//使用正则表达式的路由路径示例：</span>

<span class="comment">// 匹配任何路径中含有 a 的路径：</span>
app.<span class="keyword">get</span>(/a/, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
res.send(<span class="string">'/a/'</span>);
});
<span class="comment">// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等</span>
app.<span class="keyword">get</span>(/.*fly$/, <span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> </span>{
res.send(<span class="string">'/.*fly$/'</span>);
});
</code></pre></li>
<li><p>句柄路由：可以为请求处理多个回调函数，其行为类似中间件()。唯一的区别是这些回调函数有可能调用<code>next(&#39;route&#39;)</code>方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有的路径上继续执行没有意义，则可将控制权交给剩下的路径。</p>
<p>路由路柄有多种形式，可以是一个函数，一个函数数组，或者是两者混合。</p>
<pre><code><span class="comment">//使用一个回调函数处理路由：</span>
app.get(<span class="string">'/example/a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>{
res.send(<span class="string">'Hello from A!'</span>);
});

<span class="comment">//使用多个回调函数处理路由（记得指定 next 对象）：</span>
app.get(<span class="string">'/example/b'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
<span class="built_in">console</span>.log(<span class="string">'response will be sent by the next function ...'</span>);
next();
}, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>{
res.send(<span class="string">'Hello from B!'</span>);
});

<span class="comment">//使用回调函数数组处理路由：</span>
<span class="keyword">var</span> cb0 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
<span class="built_in">console</span>.log(<span class="string">'CB0'</span>);
next();
}
<span class="keyword">var</span> cb1 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
<span class="built_in">console</span>.log(<span class="string">'CB1'</span>);
next();
}
<span class="keyword">var</span> cb2 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>{
res.send(<span class="string">'Hello from C!'</span>);
}
app.get(<span class="string">'/example/c'</span>, [cb0, cb1, cb2]);

<span class="comment">//混合使用函数和函数数组处理路由：</span>
<span class="keyword">var</span> cb0 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
<span class="built_in">console</span>.log(<span class="string">'CB0'</span>);
next();
}
<span class="keyword">var</span> cb1 = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
<span class="built_in">console</span>.log(<span class="string">'CB1'</span>);
next();
}
app.get(<span class="string">'/example/d'</span>, [cb0, cb1], <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>{
<span class="built_in">console</span>.log(<span class="string">'response will be sent by the next function ...'</span>);
next();
}, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>{
res.send(<span class="string">'Hello from D!'</span>);
});
</code></pre></li>
</ol>
<ol>
<li><p>响应方法</p>
<ul>
<li><code>res.download()</code>： <a href="http://expressjs.com/4x/api.html#res.download" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.download)</a>提示下载文件。</li>
<li><code>res.end()</code>： <a href="http://expressjs.com/4x/api.html#res.end" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.end</a>终结响应。</li>
<li><code>res.json()</code>： <a href="http://expressjs.com/4x/api.html#res.json" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.json</a>发送一个 JSON 响应。</li>
<li><code>res.jsonp()</code>： <a href="http://expressjs.com/4x/api.html#res.jsonp" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.jsonp</a>发送一个支持 JSONP 的 JSON 响应。</li>
<li><code>res.redirect()</code>： <a href="http://expressjs.com/4x/api.html#res.redirect" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.redirect</a>重定向请求。</li>
<li><code>res.render()</code>： <a href="http://expressjs.com/4x/api.html#res.render" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.render</a>渲染视图模板。</li>
<li><code>res.send()</code>： <a href="http://expressjs.com/4x/api.html#res.send" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.send</a>发送各种类型的响应。</li>
<li><code>res.sendFile（）</code>： <a href="http://expressjs.com/4x/api.html#res.sendFile" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.sendFile</a>以八位字节流的形式发送文件。</li>
<li><code>res.sendStatus()</code>： <a href="http://expressjs.com/4x/api.html#res.sendStatus" target="_blank" rel="external">http://expressjs.com/4x/api.html#res.sendStatus</a>设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。</li>
</ul>
</li>
<li><p><code>app.route()</code>可用来创建链式路由句柄，它的路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。具体可参考这儿：<a href="http://expressjs.com/4x/api.html#router" target="_blank" rel="external">http://expressjs.com/4x/api.html#router</a>。</p>
<p>下面是一个例子：</p>
</li>
</ol>
<pre><code>app.route(<span class="string">'/book'</span>)
.<span class="built_in">get</span>(<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> {</span>
<span class="keyword">res</span>.send(<span class="string">'Get a random book'</span>);
})
.post(<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> {</span>
<span class="keyword">res</span>.send(<span class="string">'Add a book'</span>);
}).<span class="keyword">put</span>(<span class="function"><span class="keyword">function</span><span class="params">(req, res)</span> {</span>
<span class="keyword">res</span>.send(<span class="string">'Update the book'</span>);
});
</code></pre><ol>
<li><p><code>express.Router</code>可用来创建模块化、可挂载的路由句柄。<code>Router</code>实例是一个完整的中间件和路由系统，因此常称其为一个<code>mini-app</code>。</p>
<p>下面的实例程序创建了一个路由模块，并加载了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。</p>
<p><code>birds.js</code>源代码：</p>
<pre><code><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);
<span class="keyword">var</span> router = express.Router();
<span class="comment">// 该路由使用的中间件</span>
router.use(<span class="function"><span class="keyword">function</span> <span class="title">timeLog</span>(<span class="params">req, res, next</span>) </span>{
<span class="built_in">console</span>.log(<span class="string">'Time: '</span>, <span class="built_in">Date</span>.now());
next();
});
<span class="comment">// 定义主页路由</span>
router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
res.send(<span class="string">'Birds home page'</span>);
});
<span class="comment">// 定义 about 路由</span>
router.get(<span class="string">'/about'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>{
res.send(<span class="string">'About birds'</span>);
});
<span class="built_in">module</span>.exports = router;
</code></pre></li>
</ol>
<pre><code>在应用中加载路由模块源代码：

    var birds = require(‘./birds’)<span class="comment">;</span>
     …
     app.use(‘/birds’, birds)<span class="comment">;</span>

应用即可处理发自<span class="escape">`/</span>birds<span class="escape">`和</span><span class="escape">`/</span>birds/about<span class="escape">`的</span>请求，并且调用为该路由指定的<span class="escape">`t</span>imeLog<span class="escape">`中</span>间件。
</code></pre>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-21T14:06:32.000Z"><a href="/2015/12/21/新手学习mongodb之九：聚合管道/">2015-12-21</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/21/新手学习mongodb之九：聚合管道/">新手学习mongodb之九：聚合管道</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>聚合操作主要秀于批量数据处理，往往将记录按条件进行分组，然后在每组上分别进行一系列操作，如，求最大最小值、平均值、求和等。</p>
<pre><code>db.orders.aggregate([
{
    <span class="variable">$group</span>:{
    _id:<span class="string">"$cust_id"</span>,
    total:{<span class="variable">$sum</span>:<span class="string">"$price"</span>}
},{<span class="variable">$sort</span>:{total:<span class="number">1</span>}}}])
</code></pre><p>聚合操作能够对记录进行复杂处理，主要用于数理统计和数据挖掘。在MongoDB中，聚合操作的输入是集合中的文档，输出可以是一条或多条文档。</p>
<p>MongoDB提供了强大的聚合功能，针对聚合操作提供了三种方式：</p>
<ul>
<li>聚合管道(Aggregation Pipeline)</li>
<li>单目的聚合操作(Single Purpose Aggregation Operation)</li>
<li>MapReduce编程模型
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/21/新手学习mongodb之九：聚合管道/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-20T14:06:32.000Z"><a href="/2015/12/20/新手学习mongodb之八：GridFS文件存储/">2015-12-20</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/20/新手学习mongodb之八：GridFS文件存储/">新手学习mongodb之：GridFS文件存储</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>文件系统是操作系统用来组织磁盘文件的方法和数据结构，计算机通过文件系统来存储管理数据。</p>
<p>典型的系统有<code>UFS(Unix File System)</code>，<code>EXT(Extended file system)</code>及<code>NTFS(New Technology File System)</code>等。</p>
</li>
<li><p>分布式文件系统，将固定存储于单台机器上的文件系统，扩展到多台机器上，每个节点负责存储部分数据，众多的存储节点组成一个文件系统网络，各个节点之间通过网络进行信和数据传输。</p>
<ul>
<li><code>NFS(Network File System)</code>：相当于<code>RPC Service</code>，使用者可以像使用本地文件系统一样来访问远程的文件。</li>
<li><code>HDFS(Hadoop File System)</code>:采用<code>master/slave</code>架构设计，可以运行于廉价的普通硬件之上，适合超大数据集的应用程序。</li>
<li><code>TFS(Taobao File System)</code>：适合海量非结构化的小文件存储，采用HA架构；文件名可以直接映射到物理地址。</li>
<li><p><code>FastDFS</code>：轻量级的分布式文件系统；采用对等架构设计；可以根据文件ID迅速定位文件。</p>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/20/新手学习mongodb之八：GridFS文件存储/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-19T14:06:32.000Z"><a href="/2015/12/19/新手学习mongodb之七：特殊索引/">2015-12-19</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/19/新手学习mongodb之七：特殊索引/">新手学习mongodb之七：特殊索引</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li>地理空间索引可以对地理位置数据建立索引条目，Mongo原生支持地理位置索引，可以直接用于位置距离计算和查询。MongoDB对原生支持的查询函数在性能上进行了高度的优化，与其它的数据库相比，具有很高的查询效率。MongoDB支持两种类型的地理空间索引：<ul>
<li>球面：<code>2dsphere索引</code></li>
<li>平面：<code>2d索引</code>
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/19/新手学习mongodb之七：特殊索引/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-17T14:06:32.000Z"><a href="/2015/12/17/新手学习mongodb之六：普通索引/">2015-12-17</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/17/新手学习mongodb之六：普通索引/">新手学习mongodb之六：普通索引</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>所有的索引信息被保存在<strong>system.indexes</strong>集合中，且默认总是为<code>_id</code>创建索引。<code>db.system.indexes.find()</code>可以查看当前数据库中创建的所有的索引。Mongodb使用的是B-树算法。Mongodb提供的索引类型为：</p>
<ul>
<li>Single Filed:单字段索引，在普通字段、子文档以及子文档的某个字段上建立的索引。</li>
<li>Compound Index:复合索引，同时在多个字段上建立的索引。</li>
<li>Multikey Index:多键索引，对数组建立的索引。</li>
<li>Geospatial Index:地理空间索引，对地理位置数据库建立的索引{支持球面和平面}。</li>
<li>Text Index：全文索引，对每一个词建立索引，支持全文搜索。</li>
<li>Hashed Index：哈希索引，索引中存储的是被索引键的哈希值。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/17/新手学习mongodb之六：普通索引/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-16T14:06:32.000Z"><a href="/2015/12/16/新手学习mongodb之五：游标及模糊查询/">2015-12-16</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/16/新手学习mongodb之五：游标及模糊查询/">新手学习mongodb之五：游标及模糊查询</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li>使用<code>find</code>函数进行查询时，MongoDB并不是一次返回结果集中的所有文档，而是以多条文档的形式分白费来返回查询结果，返回的文档会缓存到内存中。<br>分批的原则是不超过101个文档或1M的数据，以先达到的标准为主。如果101个文档大于1M，则会减少文档的数量，以小的为准，除第一次外，以后每次可以返回4M的文档。<br>这种批量返回结果的好处是，一方面，它可以减少客户端对服务器连接次数，从而减轻服务器的查询负担；另一方面，当查询结果集很大时，批量返回的结果的方式可以减少客户端的等待时间，提高数据的处理效率。<br>在没有建立索引的字段上进行排序，会把符合条件的全部加载到内存中进行排序，所以，一定要建立索引。
      
    </div>
    <footer>
      
        
          <div class="alignleft">
            <a href="/2015/12/16/新手学习mongodb之五：游标及模糊查询/#more" class="more-link">阅读更多</a>
          </div>
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2015-12-15T14:06:32.000Z"><a href="/2015/12/15/新手学习mongodb之四：使用find轻松查询数据/">2015-12-15</a></time>
      
      
  
    <h1 class="title"><a href="/2015/12/15/新手学习mongodb之四：使用find轻松查询数据/">新手学习mongodb之四：使用find轻松查询数据</a></h1>
  

    </header>
    <div class="entry">
      
        <ol>
<li><p>find参数的原型如下：<code>db.集合名.find(query,fields,limit,skip)</code>,这四个参数的意思如下：</p>
<ul>
<li><code>query</code>：指明查询条件，相当于SQL中的where语句，例如：<code>db.std.find({name:&quot;henry&quot;,&quot;ang&quot;:{$lt:22}})</code></li>
<li><code>fields</code>:用于字段映射，语法格式:<code>{field:0}</code>或<code>{filed:1}</code>用来表示该字段在结果中是否显示。<code>1</code>为显示。如：<code>db.std.find({&quot;age&quot;:{$lt:22}},{&quot;_id&quot;:0,&quot;name&quot;:1})</code>,除<code>_id</code>字段，其它字段必须设置同样的值，要么为<code>0</code>，要么为<code>1</code>。如果<code>_id</code>为<code>1</code>，那么其他字段必须为<code>1</code>；如果<code>_id</code>字段为<code>0</code>，其他字段可同时为<code>0或1</code>。</li>
<li>limit:限制查询结果集的文档数量，指定查询返回结果数量的上限，例如：<code>db.std.find({name:&quot;henry&quot;},{&quot;name&quot;:1,&quot;age&quot;:1},5)</code></li>
<li>skip：跳过一定数据量的结果，设置第一条返回文档的偏移量。如<code>db.std.find({name:&quot;henry&quot;},{&quot;name&quot;:1,&quot;age&quot;:1},5,20)</code></li>
<li><p>返回对象为cursor对象<code>var cursor = db.std.find({name:&quot;joe&quot;})</code></p>
<p><a id="more"></a></p>
<p>使用find函数时需要注意以下问题：</p>
</li>
<li><p>一次只能查询一个集合，不能针对多个集合</p>
</li>
<li><p><code>find</code>参数为空或者查询条件为空查询时，会返回集合中的所有文档。<code>db.std.find()</code>或<code>db.std.find()</code></p>
</li>
<li>除了将<code>limit</code>和<code>skip</code>作为<code>find</code>函数的参数外，还可以单独使用<code>limit</code>和<code>skip</code>函数来修饰查询结果。<code>db.std.find({age:{$lt:22}}).limit(5).skip(10)</code></li>
<li>返回的查询结果默认情况下是无序的，如果需要对结果进行排序，可以使用sort函数。例如：db.std.find().sort({name:1,age:-1})</li>
<li>db.collection.findOne()只会返回第一条数据</li>
<li>当查询的集合文档数量很大时，为了加快数据的查询速度可以创建索引</li>
<li><p>除了使用find函数实现基本查询外，还可以使用聚合框架，用于复杂查询。</p>
<pre><code>dbService = connect(<span class="string">"localhost:27017"</span>);
db = dbService.getSiblingDB(<span class="string">"okuc"</span>);
db.query_test.drop();
<span class="variable"><span class="keyword">var</span> bulk</span> = db.query_test.initializeUnorderedBulkOp();
<span class="variable"><span class="keyword">var</span> doc1</span> = {
            name:<span class="string">"joe"</span>,
            age:<span class="number">20</span>
}
bulk.insert(doc1);
<span class="variable"><span class="keyword">var</span> doc2</span> = {
            name:<span class="string">"joe"</span>,
            age:<span class="number">31</span>
}
bulk.insert(doc2);
<span class="variable"><span class="keyword">var</span> doc3</span> = {
            name:<span class="string">"henry"</span>,
            age:<span class="number">21</span>
}
bulk.insert(doc3);
<span class="variable"><span class="keyword">var</span> doc4</span> = {
            name:<span class="string">"john"</span>,
            age:<span class="literal">null</span>
}
bulk.insert(doc4);

bulk.execute()

<span class="variable"><span class="keyword">var</span> cursor</span> = db.query_test.find(
        {},<span class="comment">//查询条件</span>
        {_id:<span class="number">0</span>,age:<span class="number">1</span>},<span class="comment">//字段映射</span>
        <span class="number">2</span>,<span class="comment">//返回结果条数</span>
        <span class="number">1</span>).sort({age:<span class="number">1</span>});<span class="comment">//跳过文档条件 结果按照年龄升序排列</span>
);
printjson(cursor.toArray())

<span class="variable"><span class="keyword">var</span> cursor</span> = db.query_test.find(
        {},<span class="comment">//查询条件</span>
        {_id:<span class="number">0</span>,age:<span class="number">1</span>}).limit(<span class="number">2</span>).skip(<span class="number">1</span>).sort({age:<span class="number">1</span>});
);
printjson(cursor.toArray())
</code></pre></li>
</ul>
</li>
<li><p>比较查询操作符共有以下几种：</p>
<ul>
<li><code>$wq / $ne</code>:等于/不等于<code>{&lt;field&gt;:{$eq:&lt;value&gt;}}</code></li>
<li><code>$gt / $gte</code>:大于/大于等于<code>{&lt;field&gt;:{$gt:&lt;value&gt;}}</code></li>
<li><code>$lt / $lte</code>:小于/小于等于<code>{&lt;field&gt;:{$lt:&lt;value&gt;}}</code></li>
<li><code>$in / $nin</code>：包含/不包含<code>{&lt;field&gt;:{$in:[&lt;value1&gt;,&lt;value2&gt;...&lt;valueN&gt;]}}</code></li>
</ul>
</li>
<li><p>利用逻辑查询操作符还可以连接多个查询条件</p>
<ul>
<li><code>$and</code>:与<code>{$and:[{&lt;expression1&gt;},&lt;expression2&gt;},...,&lt;expressionN&gt;}]}</code></li>
<li><code>$or</code>：或<code>{$or:[{&lt;expression1&gt;},&lt;expression2&gt;},...,&lt;expressionN&gt;}]}</code></li>
<li><code>$nor</code>:非<code>{$nor:[{&lt;expression1&gt;},&lt;expression2&gt;},...,&lt;expressionN&gt;}]}</code></li>
<li><code>$not</code>：取反<code>{$not:[{&lt;expression1&gt;},&lt;expression2&gt;},...,&lt;expressionN&gt;}]}</code></li>
</ul>
</li>
<li><p>元素查询操作符</p>
<ul>
<li><code>$exists</code>:按照字段是否存在来查询文档<code>{field:{$exists:&lt;boolean&gt;}}</code></li>
<li><p><code>$type</code>:选择字段值为指定BSON数据类型编号的文档<code>{field:{$type:&lt;BSON type&gt;}}</code></p>
<pre><code>dbService = connect(<span class="string">"localhost:27017"</span>);
db = dbService.getSiblingDB(<span class="string">"okuc"</span>);
db.query_test.drop();
var bulk = db.query_test.initializeUnorderedBulkOp();
var doc1 = {
            name:<span class="string">"joe"</span>,
            age:<span class="number">20</span>
}
bulk.<span class="keyword">insert</span>(doc1);
var doc2 = {
            name:<span class="string">"joe"</span>,
            age:<span class="number">31</span>
}
bulk.<span class="keyword">insert</span>(doc2);
var doc3 = {
            name:<span class="string">"henry"</span>,
            age:<span class="number">21</span>
}
bulk.<span class="keyword">insert</span>(doc3);
var doc4 = {
            name:<span class="string">"john"</span>,
            age:null
}
bulk.<span class="keyword">insert</span>(doc4);

bulk.execute()

var cursor = db.query_test.find(
        {
    age:{<span class="variable">$eq</span>:<span class="number">20</span>}//也可以写成 age:<span class="number">20</span>
    //age:<span class="number">20</span>
    }
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {
        {
    age:{<span class="variable">$nin</span>:[<span class="number">20</span>,<span class="number">21</span>]}//键值等于<span class="number">20</span>,<span class="number">21</span>的文档
    //age:<span class="number">20</span>
    }
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {//查询年龄等于<span class="number">19</span>或<span class="number">21</span>且名字等于joe或jack的数据
    <span class="variable">$and</span>:[{ <span class="variable">$or</span>:[{age:<span class="number">19</span>},age:<span class="number">21</span>]},
          { <span class="variable">$or</span>:[{name:<span class="string">"joe"</span>},{name:<span class="string">"jack"</span>}]}
    ]
    //age:<span class="number">20</span>
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {
    <span class="variable">$nor</span>:[{name:<span class="string">"joe"</span>},{name:<span class="string">"jack"</span>}]//查出姓名不等于joe或jack的人
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {
    age:{<span class="variable">$not</span>:{<span class="variable">$gt</span>:<span class="number">22</span>,<span class="variable">$lte30</span>}}年龄小于等于<span class="number">22</span>，且大于<span class="number">30</span>
});
printjson(cursor.toArray())

var cursor = db.query_test.find(
        {
    age:{<span class="variable">$exists</span>:true}//存在年龄的人
});
printjson(cursor.toArray())
</code></pre></li>
</ul>
</li>
<li><p>查询操作符介绍及使用–<code>$where</code>查询</p>
<p><code>$where</code>可以将JavaScript表达式的字符串或JavaScript函数作为查询语句的一部分，在JavaScript表达式和函数中，可以使用this或obj来引用当前操作的文档。<code>db.collection.find({$where:&quot;this.credits == this.debits&quot;})</code>,只有js或函数返回值为true时，才会返回当前文档。</p>
<p>查询时，<code>$where</code>操作符不能使用索引，每个文档需要从BSON对象转换成JS对象后，才可以通过<code>$where</code>表达式来运行。所以，比一般查询要慢，因此要避免使用。</p>
<pre><code>dbService = connect(<span class="string">"localhost:27017"</span>);
db = dbService.getSiblingDB(<span class="string">"okuc"</span>);
db.query_test.drop();
<span class="keyword">var</span> bulk = db.query_test.initializeUnorderedBulkOp();
<span class="keyword">var</span> doc1 = {
            <span class="string">"apple"</span>:<span class="number">1</span>,<span class="string">"banana"</span>:<span class="number">6</span>,<span class="string">"peach"</span>:<span class="number">4</span>
}
bulk.insert(doc1);
<span class="keyword">var</span> doc2 = {
            <span class="string">"apple"</span>:<span class="number">3</span>,<span class="string">"banana"</span>:<span class="number">3</span>,<span class="string">"peach"</span>:<span class="number">4</span>
}
bulk.insert(doc2);

bulk.execute()

<span class="keyword">var</span> cursor = db.query_test.find(
        {
     $where:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{
        <span class="keyword">for</span>(<span class="keyword">var</span> current <span class="keyword">in</span> <span class="keyword">this</span>){
            <span class="keyword">for</span>(<span class="keyword">var</span> other <span class="keyword">in</span> <span class="keyword">this</span>){
                <span class="keyword">if</span>(current !=other &amp;&amp; <span class="keyword">this</span>[current]==<span class="keyword">this</span>[other]) <span class="keyword">return</span> <span class="literal">true</span>;
            }
        }
    }
    }
});
printjson(cursor.toArray());
        <span class="keyword">var</span> cursor = db.query_test.find(
        {
     $where:<span class="string">"this.apple==1 &amp;&amp; this.banana==6"</span>
});
printjson(cursor.toArray());
</code></pre></li>
<li><p>内嵌文档查询包括两种情况</p>
<p>如果是查询整个文档，当内嵌文档键值对的数量以及键值对的顺序都相同时，才会匹配；如果是查询某个字段，需要使用点操作符。</p>
<pre><code>dbService = connect(<span class="string">"localhost:27017"</span>);
<span class="keyword">db</span> = dbService.getSiblingDB(<span class="string">"okuc"</span>);
<span class="keyword">db</span>.query_test.<span class="keyword">drop</span>();
<span class="keyword">var</span> bulk = <span class="keyword">db</span>.query_test.initializeUnorderedBulkOp();
<span class="keyword">var</span> doc1 = {
            <span class="string">"name"</span>:<span class="string">"xiaoli"</span>,<span class="string">"age"</span>:20,<span class="string">"address"</span>:
{<span class="string">"province"</span>:<span class="string">"GuangDong"</span>,<span class="string">"city"</span>:ShenZhen}
}
bulk.insert(doc1);
<span class="keyword">var</span> doc2 = {
            <span class="string">"name"</span>:<span class="string">"xiaoqing"</span>,<span class="string">"age"</span>:22,<span class="string">"address"</span>:
{<span class="string">"city"</span>:ShenZhen,<span class="string">"province"</span>:<span class="string">"GuangDong"</span>}
}
bulk.insert(doc2);

bulk.execute()

<span class="keyword">var</span> cursor = <span class="keyword">db</span>.query_embedded.fin({
    <span class="string">"address"</span>:{
        <span class="string">"province"</span>:<span class="string">"GuangDong"</span>
    }
});
printjson(cursor.toArray());
</code></pre></li>
<li><p>数组查询</p>
<ul>
<li><code>$all</code>:查询包含参数数组中所有元素的文档</li>
<li><code>$elemMatch</code>:多条件查询</li>
<li><code>$size</code>：查询指定长度的数组</li>
<li>`&lt;div class=”entry”:返回第一个匹配的数组元素</li>
<li><code>$elemMatch</code>：按条件返回数组元素的子集</li>
<li><p><code>$slice</code>：返回连续数组元素的子集</p>
<pre><code>dbService = connect(<span class="string">"localhost:27017"</span>);
db = dbService.getSiblingDB(<span class="string">"okuc"</span>);
db.query_test.drop();
var bulk = db.query_test.initializeUnorderedBulkOp();
var doc1 = {_id:<span class="number">5</span>,
            name:<span class="string">"xiaoli"</span>,
            age:<span class="number">20</span>,
            scores:[<span class="number">95</span>,<span class="number">98</span>,<span class="number">99</span>]
}
bulk.<span class="keyword">insert</span>(doc1);
var doc2 = {_id:<span class="number">6</span>,
            name:<span class="string">"xiaoqiang"</span>,
            age:<span class="number">22</span>,
            scores:[<span class="number">95</span>,<span class="number">99</span>]
}
bulk.<span class="keyword">insert</span>(doc2);
var doc3 = {_id:<span class="number">7</span>,
            name:<span class="string">"xiaoming"</span>,
            age:<span class="number">22</span>,
            scores:[<span class="number">99</span>,<span class="number">95</span>,<span class="number">98</span>]
}
bulk.<span class="keyword">insert</span>(doc3);                
bulk.execute()

var cursor = db.query_array.find(//整个数组查询
    {
        scores:[<span class="number">95</span>,<span class="number">98</span>,<span class="number">99</span>]
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//整个数组查询
    {
        scores:[<span class="number">95</span>,<span class="number">98</span>,<span class="number">99</span>]
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询数组包括<span class="number">95</span>的元素
    {
        scores:<span class="number">95</span>
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询数组第一个元素是<span class="number">95</span>的元素
    {
        scores.<span class="number">0</span>:<span class="number">95</span>
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询数组包括<span class="number">99</span>,<span class="number">98</span>两个元素的文档，顺序可以不同
    {
        scores:{
            <span class="variable">$all</span>:[<span class="number">99</span>,<span class="number">98</span>]
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询scores数组中有一个元素大于等于<span class="number">95</span>，且小于等于<span class="number">99</span>的元素
    {
        scores:{
            <span class="variable">$elemMatch</span>:{<span class="variable">$gt</span>:<span class="number">95</span>,<span class="variable">$lt</span>:<span class="number">99</span>}
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询scores数组中有一个元素大于等于<span class="number">95</span>，还有一个元素小于等于<span class="number">99</span>的数组
    {
        scores:{
            <span class="variable">$gt</span>:<span class="number">95</span>,<span class="variable">$lt</span>:<span class="number">99</span>
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//只显示大于等于<span class="number">95</span>且小于等于<span class="number">99</span>的元素
    { {},//查询条件
        {scores:{//查询映射
            <span class="variable">$elemMatch</span>:{<span class="variable">$gt</span>:<span class="number">95</span>,<span class="variable">$lt</span>:<span class="number">99</span>}
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询指定长度的数组
    { 
        {scores:{
            <span class="variable">$size</span>:<span class="number">2</span>
        }}
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//显示时跳过第一个元素，最多只显示两个元素
    { {},//查询条件
        {scores:{//查询映射
            <span class="variable">$slice</span>:[<span class="number">1</span>,<span class="number">2</span>]
        }
    }
);
printjson(cursor.toArray());

var cursor = db.query_array.find(//查询数组中分数大于等于<span class="number">94</span>的数组元素
    { {scores：{<span class="variable">$gt</span>:<span class="number">94</span>}},//查询条件
        { <span class="string">"scores.$"</span>:<span class="number">1</span>;//只显示第一个元素。这个映射必须出现在查询条件中
        }
    }
);
printjson(cursor.toArray());

dbService = connect(<span class="string">"localhost:27017"</span>);
db = dbService.getSiblingDB(<span class="string">"okuc"</span>);
db.query_test.drop();
var bulk = db.query_test.initializeUnorderedBulkOp();
var doc1 = {_id:<span class="number">1</span>,
            name:<span class="string">"xiaoli"</span>,
            age:<span class="number">20</span>,
            scores:[{课程：<span class="string">"语文"</span>，成绩：<span class="number">90</span>},{课程：<span class="string">"数学"</span>，成绩：<span class="number">95</span>}]
}
bulk.insert(doc1);
var doc2 = {id:<span class="number">1</span>,
            name:<span class="string">"xiaoqiang"</span>,
            age:<span class="number">22</span>,
            scores:[{课程：<span class="string">"语文"</span>，成绩：<span class="number">92</span>},{课程：<span class="string">"英语"</span>，成绩：<span class="number">90</span>}]
}
bulk.insert(doc2);

bulk.execute()

var cursor = db.array_embedded.find({<span class="string">'scores.成绩'</span>：<span class="number">90</span>});//不使用数组索引，查询数组中成绩为<span class="number">90</span>的元素
printjson(cursor.toArray());

var cursor = db.array_embedded.find({<span class="string">'scores.1.成绩'</span>：<span class="number">90</span>});//使用数组索引，查询数组第二个元素中成绩为<span class="number">90</span>的元素
printjson(cursor.toArray());

var cursor = db.array_embedded.find({<span class="string">'scores:{$elemMatch:{"课程":"语文","成绩"：90}}});//查询数组中包含课程为语文，成绩为90的文档
printjson(cursor.toArray());</span>
</code></pre></li>
</ul>
</li>
</ol>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
    <a href="/" class="alignleft prev">Prev</a>
  
  
    <a href="/page/3/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Angularjs/">Angularjs</a><small>6</small></li>
  
    <li><a href="/tags/Bootstrap/">Bootstrap</a><small>5</small></li>
  
    <li><a href="/tags/HBase/">HBase</a><small>1</small></li>
  
    <li><a href="/tags/Nodejs/">Nodejs</a><small>7</small></li>
  
    <li><a href="/tags/TinkerPop3/">TinkerPop3</a><small>1</small></li>
  
    <li><a href="/tags/centos/">centos</a><small>2</small></li>
  
    <li><a href="/tags/docker/">docker</a><small>1</small></li>
  
    <li><a href="/tags/eclipse/">eclipse</a><small>1</small></li>
  
    <li><a href="/tags/eclipse插件开发/">eclipse插件开发</a><small>1</small></li>
  
    <li><a href="/tags/elasticsearch/">elasticsearch</a><small>6</small></li>
  
    <li><a href="/tags/express/">express</a><small>4</small></li>
  
    <li><a href="/tags/hexo/">hexo</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/linux/">linux</a><small>5</small></li>
  
    <li><a href="/tags/markdown/">markdown</a><small>2</small></li>
  
    <li><a href="/tags/maven/">maven</a><small>1</small></li>
  
    <li><a href="/tags/mongodb/">mongodb</a><small>9</small></li>
  
    <li><a href="/tags/mysql/">mysql</a><small>1</small></li>
  
    <li><a href="/tags/nodejs/">nodejs</a><small>1</small></li>
  
    <li><a href="/tags/svg/">svg</a><small>1</small></li>
  
    <li><a href="/tags/titan/">titan</a><small>1</small></li>
  
    <li><a href="/tags/tomcat/">tomcat</a><small>1</small></li>
  
    <li><a href="/tags/前端/">前端</a><small>17</small></li>
  
    <li><a href="/tags/可视化/">可视化</a><small>1</small></li>
  
    <li><a href="/tags/图数据库/">图数据库</a><small>1</small></li>
  
    <li><a href="/tags/恢复/">恢复</a><small>1</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>9</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 okuc
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>